# 11ì¥ ëª¨ë‚˜ë“œ

<details><summary>Table of Contents</summary>

-   11-1 ëª¨ë‚˜ë“œ ì´í•´í•˜ê¸° [:link:](#11-1-ëª¨ë‚˜ë“œ-ì´í•´í•˜ê¸°)
    -   íƒ€ì… í´ë˜ìŠ¤ë€? [:link:](#íƒ€ì…-í´ë˜ìŠ¤ë€)
    -   ê³ ì°¨ íƒ€ì…ì´ë€? [:link:](#ê³ ì°¨-íƒ€ì…ì´ë€)
    -   ì¹´í…Œê³ ë¦¬ ì´ë¡ ì´ë€? [:link:](#ì¹´í…Œê³ ë¦¬-ì´ë¡ ì´ë€)
    -   íŒíƒ€ì§€ëœë“œ ê·œê²© [:link:](#íŒíƒ€ì§€ëœë“œ-ê·œê²©)
    -   ëª¨ë‚˜ë“œ ë£° [:link:](#ëª¨ë‚˜ë“œ-ë£°)
-   11-2 Identity ëª¨ë‚˜ë“œ ì´í•´ì™€ êµ¬í˜„ [:link:](#11-2-identity-ëª¨ë‚˜ë“œ-ì´í•´ì™€-êµ¬í˜„)
    -   í”„ë¡œì íŠ¸ êµ¬ì„± [:link:](#í”„ë¡œì íŠ¸-êµ¬ì„±)
    -   ê°’ ì»¨í…Œì´ë„ˆ êµ¬í˜„ìš© IValuable\<T> ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ [:link:](#ê°’-ì»¨í…Œì´ë„ˆ-êµ¬í˜„ìš©-ivaluablet-ì¸í„°í˜ì´ìŠ¤-êµ¬í˜„)
    -   í´ë˜ìŠ¤ ì´ë¦„ì´ ì™œ Identity ì¸ê°€? [:link:](#í´ë˜ìŠ¤-ì´ë¦„ì´-ì™œ-identity-ì¸ê°€)
    -   ê°’ ì»¨í…Œì´ë„ˆë¡œì„œì˜ Identity\<T> êµ¬í˜„í•˜ê¸° [:link:](#ê°’-ì»¨í…Œì´ë„ˆë¡œì„œì˜-identityt-êµ¬í˜„í•˜ê¸°)
    -   ISetoid\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„ [:link:](#isetoidt-ì¸í„°í˜ì´ìŠ¤ì™€-êµ¬í˜„)
    -   IFunctor\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„ [:link:](#ifunctort-ì¸í„°í˜ì´ìŠ¤ì™€-êµ¬í˜„)
    -   ì—”ë„í‘í„°ë€? [:link:](#ì—”ë„í‘í„°ë€)
    -   IApply\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„ [:link:](#iapplyt-ì¸í„°í˜ì´ìŠ¤ì™€-êµ¬í˜„)
    -   IApplicative\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„ [:link:](#iapplicativet-ì¸í„°í˜ì´ìŠ¤ì™€-êµ¬í˜„)
    -   IChian\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„ [:link:](#ichiant-ì¸í„°í˜ì´ìŠ¤ì™€-êµ¬í˜„)
    -   IMonad\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„ [:link:](#imonadt-ì¸í„°í˜ì´ìŠ¤ì™€-êµ¬í˜„)
-   11-3 Maybe ëª¨ë‚˜ë“œ ì´í•´ì™€ êµ¬í˜„ [:link:](#11-3-maybe-ëª¨ë‚˜ë“œ-ì´í•´ì™€-êµ¬í˜„)
    -   í”„ë¡œì íŠ¸ êµ¬ì„± [:link:](#2)
    -   Maybe ëª¨ë‚˜ë“œë€? [:link:](#maybe-ëª¨ë‚˜ë“œë€)
    -   Maybe í´ë˜ìŠ¤ êµ¬ì¡° [:link:](#maybe-í´ë˜ìŠ¤-êµ¬ì¡°)
    -   Maybeê°€ í•¨ìˆ˜ì˜ ë°˜í™˜ íƒ€ì…ì¼ ë•Œì˜ ë¬¸ì œì  [:link:](#maybeê°€-í•¨ìˆ˜ì˜-ë°˜í™˜-íƒ€ì…ì¼-ë•Œì˜-ë¬¸ì œì )
    -   Just ëª¨ë‚˜ë“œ êµ¬í˜„ [:link:](#just-ëª¨ë‚˜ë“œ-êµ¬í˜„)
    -   Nothing ëª¨ë‚˜ë“œ êµ¬í˜„ [:link:](#nothing-ëª¨ë‚˜ë“œ-êµ¬í˜„)
    -   Justì™€ Nothing ëª¨ë‚˜ë“œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ [:link:](#justì™€-nothing-ëª¨ë‚˜ë“œ-ë‹¨ìœ„-í…ŒìŠ¤íŠ¸)
    -   Maybe í…ŒìŠ¤íŠ¸ [:link:](#maybe-í…ŒìŠ¤íŠ¸)
-   11-4 Validation ëª¨ë‚˜ë“œ ì´í•´ì™€ êµ¬í˜„ [:link:](#11-4-validation-ëª¨ë‚˜ë“œ-ì´í•´ì™€-êµ¬í˜„)
    -   Validation ëª¨ë‚˜ë“œë€? [:link:](#validation-ëª¨ë‚˜ë“œë€)
    -   Validation í´ë˜ìŠ¤ êµ¬ì¡° [:link:](#validation-í´ë˜ìŠ¤-êµ¬ì¡°)
    -   Success ëª¨ë‚˜ë“œ êµ¬í˜„ [:link:](#success-ëª¨ë‚˜ë“œ-êµ¬í˜„)
    -   Failure ëª¨ë‚˜ë“œ êµ¬í˜„ [:link:](#failure-ëª¨ë‚˜ë“œ-êµ¬í˜„)
    -   ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ ê¸°ëŠ¥ êµ¬í˜„ [:link:](#ë¹„ë°€ë²ˆí˜¸-ê²€ì¦-ê¸°ëŠ¥-êµ¬í˜„)
    -   ì´ë©”ì¼ ì£¼ì†Œ ê²€ì¦ ê¸°ëŠ¥ êµ¬í˜„ [:link:](#ì´ë©”ì¼-ì£¼ì†Œ-ê²€ì¦-ê¸°ëŠ¥-êµ¬í˜„)
-   11-5 IO ëª¨ë‚˜ë“œ ì´í•´ì™€ êµ¬í˜„ [:link:](#11-5-io-ëª¨ë‚˜ë“œ-ì´í•´ì™€-êµ¬í˜„)

</details>

## 11-1 ëª¨ë‚˜ë“œ ì´í•´í•˜ê¸°

### íƒ€ì… í´ë˜ìŠ¤ë€?

**íƒ€ì… í´ë˜ìŠ¤**ì˜ í•„ìš”ì„±ì„ ì´í•´í•˜ëŠ” ê²ƒì€ **ëª¨ë‚˜ë“œ**ë¥¼ ì´í•´í•˜ê¸° ìœ„í•´ ì¤‘ìš”í•˜ë‹¤.<br/>
ì•„ë˜ì˜ 2ì°¨ ê³ ì°¨ í•¨ìˆ˜ `callMap`ì€ ê³ ì°¨ ë§¤ê°œë³€ìˆ˜ `b`ê°€ `map` ë©”ì„œë“œë¥¼ ê°€ì¡Œë‹¤ëŠ” ê°€ì •ìœ¼ë¡œ êµ¬í˜„ë˜ì—ˆë‹¤.<br/>

```typescript
const callMap = (fn) => (b) => b.map(fn);
```

ë”°ë¼ì„œ ì•„ë˜ì™€ ê°™ì€ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•œë‹¤.<br/>

```typescript
callMap((a) => a + 1)([1]);
```

í•˜ì§€ë§Œ ì•„ë˜ì™€ ê°™ì´ ì‘ì„±ì‹œ í”„ë¡œê·¸ë¨ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œëœë‹¤.<br/>

```typescript
callMap((a) => a + 1)(1);
```

ì´ë¥¼ ë°©ì§€í•˜ë ¤ë©´ ì•„ë˜ì²˜ëŸ¼ ë§¤ê°œë³€ìˆ˜ `b`ëŠ” ë°˜ë“œì‹œ `map` ë©”ì„œë“œê°€ ìˆëŠ” íƒ€ì…ìœ¼ë¡œ ì œí•œí•´ì•¼ í•œë‹¤.<br/>

```typescript
const callMap = <T, U>(fn: (T) => U) => <T extends { map(fn) }>(b: T) =>
    b.map(fn);
```

ì•„ë˜ì™€ ê°™ì´ `map` ë©”ì„œë“œê°€ ì—†ëŠ” `1`ì€ ê³ ì°¨ ë§¤ê°œë³€ìˆ˜ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.<br/>

<img src="./images/1.png" width="500" height="auto">

ë”°ë¼ì„œ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ì‹œì ì— í”„ë¡œê·¸ë¨ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ì •ë£Œë˜ëŠ” ê²ƒì„ ë§‰ì„ ìˆ˜ ìˆë‹¤.<br/>
ë³´í†µ ê°ì²´ì§€í–¥ ì–¸ì–´ë¼ë©´ `map` ë©”ì„œë“œë¥¼ ê°–ëŠ” `Number` í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” ì‹ìœ¼ë¡œ ì„¤ê³„í•  ê²ƒì´ë‹¤.<br/>
í•˜ì§€ë§Œ **ëª¨ë‚˜ë“œ** ë°©ì‹ ì„¤ê³„ëŠ” ë°˜ë“œì‹œ `map`ê³¼ `of`ë¼ëŠ” ë©”ì„œë“œê°€ ìˆëŠ” `Monad<T>` í´ë˜ìŠ¤ë¥¼ ë§Œë“ ë‹¤.<br/>

```typescript
class Monad<T> {
    constructor(public value: T) {}
    static of<U>(value: U): Monad<U> {
        return new Monad<U>(value);
    }
    map<U>(fn: (x: T) => U): Monad<U> {
        return new Monad<U>(fn(this.value));
    }
}
```

ì´ì²˜ëŸ¼ `Monad<T>`ì™€ ê°™ì€ í´ë˜ìŠ¤ë¥¼ **íƒ€ì… í´ë˜ìŠ¤**ë¼ê³  í•œë‹¤.<br/>
**íƒ€ì… í´ë˜ìŠ¤**ëŠ” ë‹¤ìŒì²˜ëŸ¼ í•¨ìˆ˜ë¥¼ ë§Œë“¤ ë•Œ íŠ¹ë³„í•œ íƒ€ì…ìœ¼ë¡œ ì œì•½í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.<br/>

```typescript
const callMonad = (fn) => (b) => Monad.of(b).map(fn).value;
```

**íƒ€ì… í´ë˜ìŠ¤** ë•ë¶„ì— **íƒ€ì…ì— ë”°ë¥¸ ì•ˆì •ì„±ì„ ë³´ì¥**í•˜ê³  ì½”ë“œì˜ **ì¬ì‚¬ìš©ì„±ì´ ë›°ì–´ë‚œ ë²”ìš© í•¨ìˆ˜**ë¥¼ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.<br/>

```typescript
callMonad((a: number) => a + 1)(1); // 2
callMonad((a: number[]) => a.map((value) => value + 1))([1, 2, 3, 4]); // [ 2, 3, 4, 5 ]
```

`callMonad`ì™€ ê°™ì€ í•¨ìˆ˜ëŠ” í•œ ë²ˆë§Œ ë§Œë“¤ë©´ ìœ„ì²˜ëŸ¼ **ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì— ë¬´ê´€**í•œ ê°„ê²°í•œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.<br/>

### ê³ ì°¨ íƒ€ì…ì´ë€?

`Monad<T>`ëŠ” íƒ€ì… `T`ë¥¼ `Monad<T>`ë¡œ ë³€í™˜í–ˆë‹¤ ë‹¤ì‹œ íƒ€ì… `T`ë¡œ ë³€í™˜í•´ì¤€ë‹¤.<br/>
`Monad<T>`ì™€ ê°™ì´ íƒ€ì… `T`ë¥¼ í•œ ë‹¨ê³„ ë” ë†’ì€ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ìš©ë„ì˜ íƒ€ì…ì„ **ê³ ì°¨ íƒ€ì…**ì´ë¼ í•œë‹¤.<br/>
**ê³ ì°¨ íƒ€ì…**ì€ **ì¹´í…Œê³ ë¦¬ ì´ë¡ **ì´ë¼ëŠ” ìˆ˜í•™ì—ì„œ ì•„ì´ë””ì–´ë¥¼ ì–»ì—ˆë‹¤.<br/>
Typescriptì—ì„œëŠ” `Monad<T>`ì™€ ê°™ì´ **2ì°¨ ê³ ì°¨ íƒ€ì…**ì„ ë§Œë“¤ ìˆ˜ ìˆê²Œ í•˜ëŠ” êµ¬ë¬¸ì„ ì œê³µí•œë‹¤.<br/>
í•˜ì§€ë§Œ ìŠ¤ì¹¼ë¼ ì–¸ì–´ì²˜ëŸ¼ `Functor[F[_]]` ê°™ì€ 3ì°¨ ì´ìƒì˜ ê³ ì°¨ íƒ€ì…ì€ ë§Œë“¤ ìˆ˜ ì—†ë‹¤.<br/>

### ì¹´í…Œê³ ë¦¬ ì´ë¡ ì´ë€?

**ì¹´í…Œê³ ë¦¬ ì´ë¡ **ì€ 1940ë…„ì— ì‹œì‘ëœ ìˆ˜í•™ì˜ í•œ ë¶„ì•¼ë¡œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì˜ ì¤‘ìš”í•œ ì´ë¡ ì ì¸ ë°°ê²½ì´ ë˜ì—ˆë‹¤.<br/>
**ì¹´í…Œê³ ë¦¬ ì´ë¡ **ì€ í”íˆ ì•„ë˜ì˜ ê·¸ë¦¼ìœ¼ë¡œ í‘œí˜„ëœë‹¤.<br/>

<img src="./images/2.png" width="500" height="auto">

ìˆ˜í•™ì—ì„œ **ì§‘í•©**ì€ í”„ë¡œê·¸ë˜ë°ì—ì„œì˜ **íƒ€ì…**ì´ë‹¤.<br/>
ìˆ˜í•™ì—ì„œ **ì¹´í…Œê³ ë¦¬**ëŠ” **ì§‘í•©ì˜ ì§‘í•©**ìœ¼ë¡œ ì´í•´í•  ìˆ˜ ìˆë‹¤.<br/>
ë”°ë¼ì„œ í”„ë¡œê·¸ë˜ë°ì—ì„œì˜ **ì¹´í…Œê³ ë¦¬**ëŠ” **íƒ€ì…ì˜ íƒ€ì…**ìœ¼ë¡œ **ê³ ì°¨ íƒ€ì…**ìœ¼ë¡œ ì´í•´í•  ìˆ˜ ìˆë‹¤.<br/>
ë˜í•œ **ëª¨ë‚˜ë“œ**ëŠ” ë³„ë„ì˜ íŠ¹ì§•ì´ ìˆëŠ” **ê³ ì°¨ íƒ€ì…**ì´ë‹¤.<br/>

### íŒíƒ€ì§€ëœë“œ ê·œê²©

**ëª¨ë‚˜ë“œ**ëŠ” í•˜ìŠ¤ì¼ˆ ì–¸ì–´ì˜ `Prelude`ë¼ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì‚¬ìš©ë˜ëŠ” ìš©ì–´ì´ê¸°ë„ í•˜ë‹¤.<br/>
**ëª¨ë‚˜ë“œ**ëŠ” **ëª¨ë‚˜ë“œ ë£°**ì´ë¼ê³  í•˜ëŠ” ì½”ë“œ ì„¤ê³„ ì›ì¹™ì— ë§ì¶° êµ¬í˜„ëœ í´ë˜ìŠ¤ë¥¼ ì˜ë¯¸í•œë‹¤.<br/>
ì•„ë˜ ê·¸ë¦¼ì€ Githubì— ìˆëŠ” [íŒíƒ€ì§€ëœë“œ ê·œê²©](https://github.com/fantasyland/fantasy-land)ì— ìˆëŠ” ê·¸ë¦¼ ì¤‘ ë¶€ë¶„ì´ë‹¤.<br/>

<img src="./images/3.png" width="550" height="auto">

íŒíƒ€ì§€ëœë“œ ê·œê²©ì€ í•˜ìŠ¤ì¼ˆ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬ì¡°ë¥¼ Javascript ë°©ì‹ìœ¼ë¡œ ì¬êµ¬ì„±í•œ ê²ƒì´ë‹¤.<br/>
ê·¸ë¦¼ì—ì„œ ë³´ë©´ **ëª¨ë‚˜ë“œ**ëŠ” ì•„ë˜ ë„¤ ê°€ì§€ ìš”ì†Œë¥¼ êµ¬í˜„í•œ ê²ƒì„ì„ ì•Œ ìˆ˜ ìˆë‹¤.<br/>

-   **í‘í„°**(**Functor**) : `map`ì´ë¼ëŠ” ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” í´ë˜ìŠ¤
-   **ì–´í”Œë¼ì´**(**Apply**) : **í‘í„°**ì´ë©´ì„œ `ap`ë¼ëŠ” ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” í´ë˜ìŠ¤
-   **ì• í”Œë¦¬ì»¤í‹°ë¸Œ**(**Applicative**) : **ì–´í”Œë¼ì´**ì´ë©´ì„œ `of`ë¼ëŠ” í´ë˜ìŠ¤ ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” í´ë˜ìŠ¤
-   **ì²´ì¸**(**Chain**) : **ì• í”Œë¦¬ì»¤í‹°ë¸Œ**ì´ë©´ì„œ `chain`ì´ë¼ëŠ” ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” í´ë˜ìŠ¤

ì–´ë–¤ í´ë˜ìŠ¤ê°€ ìœ„ì˜ ë„¤ ê°€ì§€ ì¡°ê±´ì„ ëª¨ë‘ ë§Œì¡±í•œë‹¤ë©´ ê·¸ í´ë˜ìŠ¤ëŠ” **ëª¨ë‚˜ë“œ**ë‹¤.<br/>

### ëª¨ë‚˜ë“œ ë£°

í´ë˜ìŠ¤ ì´ë¦„ì´ `M`ì´ê³  ì¸ìŠ¤í„´ìŠ¤ë¥¼ `m`ì´ë¼ê³  í• ë•Œ **ëª¨ë‚˜ë“œ**ëŠ” **ì• í”Œë¦¬ì»¤í‹°ë¸Œ**ì™€ **ì²´ì¸**ì˜ ê¸°ëŠ¥ì„ ê°–ëŠ”ë‹¤.<br/>
ë˜í•œ í•´ë‹¹ **ëª¨ë‚˜ë“œ** í´ë˜ìŠ¤ëŠ” ì•„ë˜ì™€ ê°™ì€ ë‘ ê°€ì§€ ë²•ì¹™ì„ ë§Œì¡±í•œë‹¤.<br/>

|             êµ¬ë¶„             |            ì˜ë¯¸            |
| :--------------------------: | :------------------------: |
|  ì™¼ìª½ ë²•ì¹™ (Left Identity)   | `M.of(a).chain(f) == f(a)` |
| ì˜¤ë¥¸ìª½ ë²•ì¹™ (Right Identity) |    `m.chain(M.of) == m`    |

í•˜ìŠ¤ì¼ˆì˜ `Prelude` í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `Maybe`ì™€ ê°™ì€ ë¯¸ë¦¬ êµ¬í˜„ëœ **ëª¨ë‚˜ë“œ**ë¥¼ ì œê³µí•œë‹¤.<br/>
TypescriptëŠ” **ëª¨ë‚˜ë“œ** ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì œê³µí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ **íŒíƒ€ì§€ëœë“œ ê·œê²©**ì— ë§ì¶° ì‘ì„±í•´ì•¼ í•œë‹¤.<br/>

[[ğŸ”ìœ„ë¡œê°€ê¸°]](#11ì¥-ëª¨ë‚˜ë“œ)&nbsp; / &nbsp;[[ğŸ”™ë’¤ë¡œê°€ê¸°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-2 Identity ëª¨ë‚˜ë“œ ì´í•´ì™€ êµ¬í˜„

### í”„ë¡œì íŠ¸ êµ¬ì„±

ì•„ë˜ì™€ ê°™ì´ Typescriptë¥¼ ì‚¬ìš©í•˜ëŠ” node.js í”„ë¡œì íŠ¸ë¥¼ êµ¬ì„±í•œë‹¤.<br/>

```shell
> npm init --y
> npm i -D typescript ts-node @types/node
> mkdir -p src/test
> mkdir src/interfaces
> mkdir src/classes
```

`tsconfig.json` íŒŒì¼ì€ ì•„ë˜ì™€ ê°™ì´ ì„¤ì •í•œë‹¤.<br/>

```typescript
{
    "compilerOptions": {
        "module": "CommonJS",
        "esModuleInterop": true,
        "target": "es5",
        "moduleResolution": "node",
        "outDir": "dist",
        "baseUrl": ".",
        "sourceMap": true,
        "downlevelIteration": true,
        "noImplicitAny": false,
        "paths": {
            "*": ["node_modules/*"]
        }
    },
    "include": ["src/**/*"]
}
```

ê¸°ì¡´ì— ì‚¬ìš©í–ˆë˜ `tsconfig.json` íŒŒì¼ ì„¤ì •ë“¤ê³¼ ë™ì¼í•˜ê²Œ ì„¤ì •í•˜ì˜€ë‹¤.<br/>

### ê°’ ì»¨í…Œì´ë„ˆ êµ¬í˜„ìš© IValuable\<T> ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„

ì–´ë–¤ íƒ€ì… `T`ê°€ ìˆì„ ë•Œ ë°°ì—´ `T[]`ëŠ” ê°™ì€ íƒ€ì…ì˜ ì•„ì´í…œì„ ì—¬ëŸ¬ ê°œ ê°€ì§„ **ì»¨í…Œì´ë„ˆ**ë‹¤.<br/>
ë³´í†µ **ì»¨í…Œì´ë„ˆ**ë¼ëŠ” ìš©ì–´ëŠ” ì´ì²˜ëŸ¼ í”íˆ **ë°°ì—´**ì„ ì˜ë¯¸í•œë‹¤.<br/>
í•˜ì§€ë§Œ `Monad<T>`ì²˜ëŸ¼ **ë°°ì—´ì´ ì•„ë‹Œ í•œ ê°œì˜ ê°’ì„ ê°€ì§€ëŠ” ì»¨í…Œì´ë„ˆ í´ë˜ìŠ¤**ë¥¼ ìƒê°í•  ìˆ˜ ìˆë‹¤.<br/>
ì´ **ì»¨í…Œì´ë„ˆ í´ë˜ìŠ¤**ëŠ” ëª¨ë“  íƒ€ì… `T`ì˜ ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ” **ì œë„¤ë¦­ ì»¨í…Œì´ë„ˆ í´ë˜ìŠ¤**ë‹¤.<br/>
ì´ì²˜ëŸ¼ íƒ€ì… `T`ë¥¼ ê°€ì§€ëŠ” ê°’ì˜ ì»¨í…Œì´ë„ˆë¥¼ **ê°’ ì»¨í…Œì´ë„ˆ**ë¼ê³  í•œë‹¤.<br/>
**ê°’ ì»¨í…Œì´ë„ˆ**ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´ ì•„ë˜ì˜ `IValuable<T>` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‘ì„±í•œë‹¤.<br/>

-   `interfaces/IValuable.ts`

```typescript
export interface IValuable<T> {
    value(): T;
}
```

ë˜í•œ ì•ìœ¼ë¡œ `Identity<T>`ì˜ ì½”ë“œë¥¼ í¸í•˜ê²Œ ì‚¬ìš©í•˜ê³ ì ì•„ë˜ì˜ ë‚´ìš©ì˜ `index.ts`ë¥¼ ì‘ì„±í•œë‹¤.<br/>

-   `interfaces/index.ts`

```typescript
import { IValuable } from "./IValuable";
import { ISetoid } from "./ISetoid";
import { IFunctor } from "./IFunctor";
import { IApplicative } from "./IApplicative";
import { IApply } from "./IApply";
import { IChain } from "./IChain";
import { IMonad } from "./IMonad";

export { IValuable, ISetoid, IFunctor, IApplicative, IApply, IChain, IMonad };
```

### í´ë˜ìŠ¤ ì´ë¦„ì´ ì™œ Identity ì¸ê°€?

**í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°**ì—ì„œ `identity`ëŠ” í•­ìƒ ì•„ë˜ì²˜ëŸ¼ êµ¬í˜„í•˜ëŠ” íŠ¹ë³„í•œ ì˜ë¯¸ì˜ í•¨ìˆ˜ë‹¤.<br/>

```typescript
const identity = <T>(value: T): T => value;
```

ì•ì—ì„œ ë³¸ `ramda` ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `R.identity` í•¨ìˆ˜ê°€ `identity`ë¥¼ êµ¬í˜„í•˜ê³  ìˆë‹¤.<br/>
`Identity`ëŠ” `map`, `ap`, `of`, `chain`ê³¼ ê°™ì€ ê¸°ë³¸ ë©”ì„œë“œë§Œ êµ¬í˜„í•œ **ëª¨ë‚˜ë“œ**ë‹¤.<br/>
**ì¹´í…Œê³ ë¦¬ ì´ë¡ **ì—ì„œ ê¸°ì¡´ íƒ€ì…ì—ì„œ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ê°”ë‹¤ ì˜¬ ë•Œ **ê°’ì´ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ì¹´í…Œê³ ë¦¬**ë¥¼ `Identity`ë¼ê³  í•œë‹¤.<br/>

```typescript
Identity.of(1).chain(Identity.of); // Identity.of(1)
```

ìœ„ ì½”ë“œì˜ `Identity<number>` íƒ€ì…ì€ `chain` ë©”ì„œë“œë¥¼ í†µí•´ ë‹¤ì‹œ ìì‹ ì˜ íƒ€ì…ìœ¼ë¡œ ëŒì•„ì˜¬ ìˆ˜ ìˆë‹¤.<br/>

### ê°’ ì»¨í…Œì´ë„ˆë¡œì„œì˜ Identity\<T> êµ¬í˜„í•˜ê¸°

ì•„ë˜ì˜ `Identity` í´ë˜ìŠ¤ëŠ” ê°’ ì†ì„±ì¸ `_value`ë¥¼ `private`í•˜ê²Œ ê°€ì§€ê³  ìˆë‹¤.<br/>
ë”°ë¼ì„œ `_value`ë¥¼ ì–»ê¸° ìœ„í•´ `public`í•œ `value` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { IValuable } from "../interfaces";

export class Identity<T> implements IValuable<T> {
    constructor(private _value: T) {}
    value() {
        return this._value;
    }
}
```

`Identity<T>` í´ë˜ìŠ¤ëŠ” `IValuable<T>` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ê³  ìˆëŠ” **ê°’ ì»¨í…Œì´ë„ˆ í´ë˜ìŠ¤ë‹¤**.<br/>

### ISetoid\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„

**íŒíƒ€ì§€ëœë“œ ê·œê²©**ì—ì„œ `setoid`ëŠ” `equals`ë¼ëŠ” ì´ë¦„ì˜ ë©”ì„œë“œë¥¼ ì œê³µí•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì˜ë¯¸í•œë‹¤.<br/>

-   `interfaces/ISetoid.ts`

```typescript
import { IValuable } from "./IValuable";

export interface ISetoid<T> extends IValuable<T> {
    equals<U>(value: U): boolean;
}
```

Typescriptë¡œ `setoid` ì¸í„°í˜ì´ìŠ¤ëŠ” ìœ„ì™€ ê°™ì´ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.<br/>
`ISetoid<T>`ì—ëŠ” ê°’ì´ ì—†ê¸° ë•Œë¬¸ì— ê°’ì„ ë¹„êµí•˜ê¸° ìœ„í•´ `IValuable<T>` ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì†í•œë‹¤.<br/>
`Identity<T>`ì— `ISetoid<T>` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid } from "../interfaces";

export class Identity<T> implements ISetoid<T> {
    constructor(private _value: T) {}
    value() {
        return this._value;
    }
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }
}
```

`ISetoid<T>` ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì†í•œ í›„ `equals` í•¨ìˆ˜ë¥¼ ìœ„ì™€ ê°™ì´ êµ¬í˜„í•˜ì˜€ë‹¤.<br/>
ì•„ë˜ì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‚¬ìš©í•´ êµ¬í˜„ëœ `ISetoid<T>` í´ë˜ìŠ¤ë¥¼ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆë‹¤.<br/>

-   `test/ISetoid-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const one = new Identity(1),
    anotherOne = new Identity(1);
const two = new Identity(2);

console.log(one.equals(anotherOne)); // true
console.log(one.equals(two)); // false
console.log(one.equals(1)); // false
console.log(one.equals(null)); // false
console.log(one.equals([1])); // false
```

ë³€ìˆ˜ `one`ì€ ë˜‘ê°™ì€ `Identity<number>` íƒ€ì… ë³€ìˆ˜ì¸ `anotherOne`ì—ë§Œ `true`ë¥¼ ë°˜í™˜í•œë‹¤.<br/>
`equals` í•¨ìˆ˜ì—ì„œ ë§¤ê°œë³€ìˆ˜ `that`ì´ `Identity`ì˜ ì¸ìŠ¤í„´ìŠ¤ì„ì„ íŒë³„í•˜ê¸° ë•Œë¬¸ì´ë‹¤.<br/>
ë§¤ê°œë³€ìˆ˜ `that`ì´ `Identity` ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ë‹ˆë©´ ë¬´ì¡°ê±´ `false`ë¥¼ ë°˜í™˜í•˜ê²Œ ëœë‹¤.<br/>
ë§Œì•½ `Identity`ì˜ ì¸ìŠ¤í„´ìŠ¤ë¼ë©´ `value` í•¨ìˆ˜ë¡œ ê°’ì„ ê°€ì ¸ì™€ `==` ì—°ì‚°ìë¡œ ë¹„êµí•˜ê²Œ ëœë‹¤.<br/>

### IFunctor\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„

**íŒíƒ€ì§€ëœë“œ ê·œê²©**ì—ì„œ **í‘í„°**ëŠ” `map`ì´ë¼ëŠ” ë©”ì„œë“œë¥¼ ì œê³µí•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë‹¤.<br/>

-   `interfaces/IFunctor.ts`

```typescript
export interface IFunctor<T> {
    map<U>(fn: (x: T) => U);
}
```

**ì¹´í…Œê³ ë¦¬ ì´ë¡ **ì—ì„œ **í‘í„°**ëŠ” **ì—”ë„ í‘í„°**ë¼ëŠ” íŠ¹ë³„í•œ ì„±ì§ˆì„ ë§Œì¡±í•´ì•¼ í•œë‹¤.<br/>
Typescript 3.7.4 ë²„ì „ì—ì„œëŠ” **ì—”ë„í‘í„°**ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆê²Œ í•˜ëŠ” êµ¬ë¬¸ì„ ì œê³µí•˜ì§€ ì•ŠëŠ”ë‹¤.<br/>
ë”°ë¼ì„œ `IFunctor`ì˜ `map` ë©”ì„œë“œì˜ ë°˜í™˜ íƒ€ì…ì„ ìƒëµí•œ ì´ìœ ëŠ” **ì—”ë„ í‘í„°**ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´ì„œë‹¤.<br/>

### ì—”ë„í‘í„°ë€?

**ì—”ë„**ëŠ” ë‹¨ì–´ ì•ì— ë¶™ëŠ” ì¼ì¢…ì˜ ì ‘ë‘ì‚¬ë‹¤.<br/>
**ì—”ë„í‘í„°**ëŠ” íŠ¹ì • ì¹´í…Œê³ ë¦¬ì—ì„œ ì¶œë°œí•´ **ë‹¤ì‹œ ì¶œë°œ ì¹´í…Œê³ ë¦¬ë¡œ ë„ì°©**í•˜ëŠ” **í‘í„°**ë¥¼ ì˜ë¯¸í•œë‹¤.<br/>
ì•„ë˜ì˜ `Identity<T>`ì˜ `map` ë©”ì„œë“œì˜ êµ¬í˜„ ë‚´ìš©ì€ **ì—”ë„í‘í„°**ë¡œ ë™ì‘í•˜ê²Œ í•˜ëŠ” ì½”ë“œë‹¤.<br/>

-   `classes/Identtiy.ts`

```typescript
import { ISetoid, IFunctor } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IFunctor<T> {
    constructor(private _value: T) {}

    // IValualbe
    value() {
        return this._value;
    }

    // ISetoid
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }

    // IFunctor
    map<U>(fn: (x: T) => U) {
        return new Identity<U>(fn(this.value()));
    }
}
```

ê°’ íƒ€ì… `T`ê°€ `U`ë¡œ ë°”ë€” ìˆ˜ëŠ” ìˆì§€ë§Œ **ì¹´í…Œê³ ë¦¬**ëŠ” ì—¬ì „íˆ `Identity`ì— ë¨¸ë¬¼ê²Œ í•œë‹¤.<br/>

### IApply\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„

**íŒíƒ€ì§€ëœë“œ ê·œê²©**ì—ì„œ **ì–´í”Œë¼ì´**ëŠ” **í‘í„°**ì´ë©´ì„œ `ap` ë©”ì„œë“œë¥¼ ì œê³µí•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë‹¤.<br/>

-   `interfaces/IApply.ts`

```typescript
import { IFunctor } from "./IFunctor";

export interface IApply<T> extends IFunctor<T> {
    ap<U>(b: U);
}
```

`IApply<T>`ë¥¼ êµ¬í˜„í•˜ëŠ” **ì»¨í…Œì´ë„ˆ**ëŠ” **ê°’ ì»¨í…Œì´ë„ˆ**ì´ë©° **ê³ ì°¨ í•¨ìˆ˜ì˜ ì»¨í…Œì´ë„ˆ**ë¡œë„ ë™ì‘í•œë‹¤.<br/>
ì•„ë˜ì™€ ê°™ì€ í…ŒìŠ¤íŠ¸ ì½”ë“œë¡œ `IApply`ì˜ ë™ì‘ì„ ì´í•´í•  ìˆ˜ ìˆë‹¤.<br/>

-   `test/IApply-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const add = (x) => (y) => x + y;
const id = new Identity(add);

console.log(id.ap(1).ap(2).value()); // 3
```

`Identity`ëŠ” `add`ë¼ëŠ” **2ì°¨ ê³ ì°¨ í•¨ìˆ˜**ë¥¼ ê°’ìœ¼ë¡œ ê°€ì§€ê³  ìˆë‹¤.<br/>
`add`ëŠ” **2ì°¨ ê³ ì°¨ í•¨ìˆ˜**ì´ë¯€ë¡œ `ap` ë©”ì„œë“œë¥¼ ë‘ ë²ˆ í˜¸ì¶œí•´ í•¨ìˆ˜ë¥¼ ë™ì‘ì‹œí‚¨ë‹¤.<br/>

```typescript
import { ISetoid, IApply } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApply<T> {
    // ... ìƒëµ ...
    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Identity.of<U>((f as Function)(b));
        }
    }
}
```

`IApply<T>` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” `Identity` í´ë˜ìŠ¤ì˜ `ap` ë©”ì„œë“œëŠ” ìœ„ì™€ ê°™ë‹¤.<br/>

### IApplicative\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„

**íŒíƒ€ì§€ëœë“œ ê·œê²©**ì—ì„œ **ì• í”Œë¦¬ì»¤í‹°ë¸Œ**ëŠ” `Apply`ë©´ì„œ `of`ë¼ëŠ” í´ë˜ìŠ¤ ë©”ì„œë“œë¥¼ ì œê³µí•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë‹¤.<br/>

-   `interfaces/IApplicative.ts`

```typescript
import { IApply } from "./IApply";

export interface IApplicative<T> extends IApply<T> {
    // static of(value: T);
}
```

Typescript 3.7.4ë²„ì „ì—ì„œëŠ” `interface`ì— ì •ì  ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ì§€ ëª»í•œë‹¤.<br/>
ë”°ë¼ì„œ ìœ„ì™€ ê°™ì´ ì£¼ì„ ì²˜ë¦¬ë¥¼ í•œ í›„ `Identity` í´ë˜ìŠ¤ì— `of` ë©”ì„œë“œë¥¼ êµ¬í˜„í•´ì•¼ í•œë‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IApplicative } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApplicative<T> {
    // ... ìƒëµ ...
    static of<T>(value: T): Identity<T> {
        return new Identity<T>(value);
    }
}
```

ë˜í•œ 3.7.4 ë²„ì „ì˜ TypescriptëŠ” ì •ì  ë©”ì„œë“œì˜ ë°˜í™˜ íƒ€ì…ì— `this`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.<br/>
ë”°ë¼ì„œ `IApply`ì˜ `of` ë©”ì„œë“œì˜ ë°˜í™˜ íƒ€ì…ì„ ìƒëµí•´ êµ¬í˜„í•˜ì˜€ë‹¤.<br/>

### IChian\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„

**íŒíƒ€ì§€ëœë“œ ê·œê²©**ì˜ **ì²´ì¸**ì€ `Apply`ë©´ì„œ `chain`ì´ë¼ëŠ” ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë‹¤.<br/>

-   `interfaces/chain.ts`

```typescript
import { IApply } from "./IApply";

export interface IChain<T> extends IApply<T> {
    chain<U>(fn: (T) => U);
}
```

**ëª¨ë‚˜ë“œ** íŠ¹ì„±ì— ë”°ë¼ `chain`ì€ `U` íƒ€ì…ì„ ë°˜í™˜í•˜ì§€ ì•Šì„ ìˆ˜ ìˆì–´ ë°˜í™˜ íƒ€ì…ì„ ì§€ì •í•˜ì§€ ì•Šì•˜ë‹¤.<br/>
**ì²´ì¸**ì˜ `chain` ë©”ì„œë“œëŠ” **í‘í„°**ì˜ `map`ê³¼ ë‹¬ë¦¬ **ì—”ë„í‘í„°**ë¡œ êµ¬í˜„í•´ì•¼í•  ì˜ë¯¸ê°€ ì—†ë‹¤.<br/>
ë”°ë¼ì„œ ì•„ë˜ ì½”ë“œì˜ `chain`ì€ `map`ê³¼ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ëŠ” ê°™ì§€ë§Œ êµ¬í˜„ ë‚´ìš©ì€ ì¡°ê¸ˆ ë‹¤ë¥´ë‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IApplicative, IChain } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApplicative<T>, IChain<T> {
    // ... ìƒëµ...
    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

**ì—”ë„ í‘í„°**ì¸ `map`ì€ í•­ìƒ ê°™ì€ ì¹´í…Œê³ ë¦¬ì— ë¨¸ë¬´ë¥¸ë‹¤.<br/>
ë°˜ë©´ì— `chain`ì€ ìì‹ ì´ ë¨¸ë¬´ë¥´ê³  ì‹¶ì€ ì¹´í…Œê³ ë¦¬ë¥¼ ìŠ¤ìŠ¤ë¡œ ì •í•´ì•¼ í•œë‹¤.<br/>

-   `test/IMap-IChain-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

console.log(
    Identity.of(1)
        .map((value) => `the count is ${value}`)
        .value()
); // the count is 1
console.log(
    Identity.of(1).chain((value) =>
        Identity.of(`the count is ${value}`).value()
    )
); // the count is 1
```

ìœ„ì˜ `map`ê³¼ `chain`ì„ ì‚¬ìš©í•˜ëŠ” ì½”ë“œëŠ” ê°™ì€ ê²°ê³¼ë¥¼ ë³´ì´ì§€ë§Œ ì‚¬ìš©ë²•ì— ì°¨ì´ê°€ ìˆë‹¤.<br/>

### IMonad\<T> ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„

**íŒíƒ€ì§€ëœë“œ ê·œê²©**ì—ì„œ **ëª¨ë‚˜ë“œ**ëŠ” ì•„ë˜ì²˜ëŸ¼ **ì²´ì¸**ê³¼ **ì• í”Œë¦¬ì»¤í‹°ë¸Œ**ë¥¼ êµ¬í˜„í•œ ê²ƒì´ë‹¤.<br/>

-   `interfaces/IMonad.ts`

```typescript
import { IChain } from "./IChain";
import { IApplicative } from "./IApplicative";

export interface IMonad<T> extends IChain<T>, IApplicative<T> {}
```

ì´ì œ ì•„ë˜ì™€ ê°™ì€ `Identity<T>` ëª¨ë‚˜ë“œê°€ ì™„ì„± ë˜ì—ˆë‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IMonad } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IMonad<T> {
    constructor(private _value: T) {}

    // IValualbe
    value() {
        return this._value;
    }

    // ISetoid
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }

    // IFunctor
    map<U>(fn: (x: T) => U) {
        return new Identity<U>(fn(this.value()));
    }

    // IApply
    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Identity.of<U>((f as Function)(b));
        }
    }

    // IApplicative
    static of<T>(value: T): Identity<T> {
        return new Identity<T>(value);
    }

    // IChain
    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

ì•„ë˜ ì½”ë“œëŠ” ì™„ì„±ëœ `Identity<T>` ëª¨ë‚˜ë“œê°€ **ì™¼ìª½ ë²•ì¹™**ì„ ë§Œì¡±í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì½”ë“œë‹¤.<br/>

-   `test/IMonad-Left-Law-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const a = 1;
const f = (a) => a * 2;

console.log(Identity.of(a).chain(f) == f(a)); // true
```

ìœ„ì˜ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´ `true`ê°€ ì¶œë ¥ë¨ì— ë”°ë¼ `Identity<T>`ê°€ **ëª¨ë‚˜ë“œ ì™¼ìª½ ë²•ì¹™**ì„ ë§Œì¡±í•œë‹¤.<br/>
ì•„ë˜ ì½”ë“œëŠ” `Identity<T>`ê°€ **ì˜¤ë¥¸ìª½ ë²•ì¹™**ì„ ë§Œì¡±í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•˜ëŠ” ë‚´ìš©ì´ë‹¤.<br/>

-   `test/IMonad-Right-Law-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const m = Identity.of(1);

console.log(m.chain(Identity.of).equals(m)); // true
```

ìœ„ì˜ ì½”ë“œì˜ ê²°ê³¼ ì—­ì‹œ `true`ê°€ ì¶œë ¥ë˜ë¯€ë¡œ `Identity<T>`ê°€ **ì˜¤ë¥¸ìª½ ë²•ì¹™**ì„ ë§Œì¡±í•œë‹¤.<br/>
ë”°ë¼ì„œ `Identity<T>`ëŠ” **ì˜¤ë¥¸ìª½ ë²•ì¹™**ê³¼ **ì™¼ìª½ ë²•ì¹™** ëª¨ë‘ ë§Œì¡±í•˜ë¯€ë¡œ ì •ìƒì ì¸ **ëª¨ë‚˜ë“œ**ë‹¤.<br/>
ì•„ë˜ ì½”ë“œëŠ” `Identity` íƒ€ì… ê°ì²´ì˜ ë©”ì„œë“œë“¤ì„ ë©”ì„œë“œ ì²´ì¸ í˜•íƒœë¡œ í˜¸ì¶œí•œë‹¤.<br/>

-   `test/IMonad-Method-Chain-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

type IPerson = { name: string; age: number };
const jack = Identity.of(["Jack", 32]);

console.log(
    jack
        .map(([name, age]) => ({ name, age }))
        .chain((p: IPerson) => Identity.of(p))
        .map(({ name, age }) => [name, age])
        .value()[0] == jack.value()[0]
); // true
```

**ëª¨ë‚˜ë“œ**ëŠ” ìœ„ì™€ ê°™ì´ **ì„ ì–¸í˜• í”„ë¡œê·¸ë˜ë°**ì„ ì—¼ë‘ì— ë‘ê³  ì„¤ê³„ë˜ì—ˆë‹¤.<br/>

[[ğŸ”ìœ„ë¡œê°€ê¸°]](#11ì¥-ëª¨ë‚˜ë“œ)&nbsp; / &nbsp;[[ğŸ”™ë’¤ë¡œê°€ê¸°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-3 Maybe ëª¨ë‚˜ë“œ ì´í•´ì™€ êµ¬í˜„

### í”„ë¡œì íŠ¸ <span id="2">êµ¬ì„±</span>

ì•„ë˜ì™€ ê°™ì´ Typescriptë¥¼ ì‚¬ìš©í•˜ëŠ” node.js í”„ë¡œì íŠ¸ë¥¼ êµ¬ì„±í•œë‹¤.<br/>
ì´ì „ í”„ë¡œì íŠ¸ì—ì„œ `ramda`ì™€ `node-fetch` íŒ¨í‚¤ì§€ë¥¼ ì¶”ê°€í•œë‹¤.<br/>
ë˜í•œ 11-2ì—ì„œ ì‘ì„±í•œ `interfaces` í´ë”ì˜ ë‚´ìš©ì„ ê·¸ëŒ€ë¡œ ë³µì‚¬í•´ ì‚¬ìš©í•œë‹¤.<br/>

```shell
> npm init --y
> npm i -S ramda node-fetch
> npm i -D typescript ts-node @types/node @types/ramda @types/node-fetch
> mkdir -p src/test
> mkdir src/classes
```

`tsconfig.json` íŒŒì¼ì€ ì•„ë˜ì™€ ê°™ì´ ì„¤ì •í•œë‹¤.<br/>

```typescript
{
    "compilerOptions": {
        "module": "CommonJS",
        "esModuleInterop": true,
        "target": "es5",
        "moduleResolution": "node",
        "outDir": "dist",
        "baseUrl": ".",
        "sourceMap": true,
        "downlevelIteration": true,
        "noImplicitAny": false,
        "paths": {
            "*": ["node_modules/*"]
        }
    },
    "include": ["src/**/*"]
}
```

ê¸°ì¡´ì— ì‚¬ìš©í–ˆë˜ `tsconfig.json` íŒŒì¼ ì„¤ì •ë“¤ê³¼ ë™ì¼í•˜ê²Œ ì„¤ì •í•˜ì˜€ë‹¤.<br/>

### Maybe ëª¨ë‚˜ë“œë€?

`Maybe`ëŠ” ì˜¤ë¥˜ì¼ ë•Œì™€ ì •ìƒì ì¼ ë•Œ ëª¨ë‘ ê³ ë ¤í•˜ë©° ì½”ë“œë¥¼ ê°„ê²°í•˜ê²Œ ì‘ì„±í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.<br/>
ì¦‰, `Maybe`ëŠ” **ë°ì´í„°ì˜ ìœ ë¬´**ì— ë”°ë¼ ì½”ë“œê°€ ì ì ˆí•˜ê²Œ ë™ì‘í•˜ë„ë¡ ì„¤ê³„ë˜ì—ˆë‹¤.<br/>
`Maybe`ëŠ” í•˜ìŠ¤ì¼ˆ `Prelude` í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” **ëª¨ë‚˜ë“œ**ë‹¤.<br/>
ì•ì—ì„œ ë§Œë“  `Option` íƒ€ì…ì„ ì´ìš©í•´ ì™„ì „í•œ **ëª¨ë‚˜ë“œ**ë¡œ ë™ì‘í•˜ëŠ” `Maybe`ë¥¼ ì‘ì„±í•œë‹¤.<br/>
`Maybe` ëª¨ë‚˜ë“œëŠ” `Option`ì˜ `Some`, `None`ê³¼ ë¹„ìŠ·í•œ `Just`ì™€ `Nothing`ì´ë¼ëŠ” íƒ€ì…ì„ ì œê³µí•œë‹¤.<br/>

```typescript
export class Maybe<T> {
    static Just<U>(value: U) {
        return new Just<U>(value);
    }
    static Nothing = new Nothing();
}
```

`Maybe`ëŠ” ê·¸ ìì²´ê°€ ëª¨ë‚˜ë“œê°€ ì•„ë‹ˆë¼, `Maybe`ê°€ ì œê³µí•˜ëŠ” `Just<T>`ì™€ `Nothing` íƒ€ì…ì´ **ëª¨ë‚˜ë“œ**ë‹¤.<br/>
`Maybe`ì˜ ì´ëŸ° ì„¤ê³„ ëª©ì ì€ ì½”ë“œì˜ ì•ˆì •ì„±ì„ í•¨ìˆ˜í˜• ë°©ì‹ìœ¼ë¡œ ë³´ì¥í•˜ê¸° ìœ„í•´ì„œë‹¤.<br/>
ì˜ˆë¥¼ ë“¤ì–´ TypescriptëŠ” ìˆ˜ë¥¼ `0`ìœ¼ë¡œ ë‚˜ëˆ„ë©´ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ì§€ ì•Šê³  `Infinity`ê°’ì„ ë°˜í™˜í•œë‹¤.<br/>
`Infinity`ëŠ” `number` íƒ€ì…ì˜ ê°’ì´ë¯€ë¡œ í”„ë¡œê·¸ë¨ì´ ì •ìƒ ì¢…ë£Œë˜ì§€ëŠ” ì•Šì§€ë§Œ í˜¼ë€ì„ ì¤„ ìˆ˜ ìˆë‹¤.<br/>
ì´ì²˜ëŸ¼ `undefined`, `Infinity` ë“±ì˜ ê°’ì´ ìƒê¸¸ ë•Œ `Maybe`ë¥¼ ì‚¬ìš©í•˜ë©´ íš¨ìœ¨ì ìœ¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.<br/>

```typescript
import { Maybe, IMaybe } from "../classes/Maybe";

const divide = (a: number) => (b: number): IMaybe<number> =>
    b ? Maybe.Just(a / b) : Maybe.Nothing;
```

ìœ„ì˜ ì½”ë“œëŠ” `b`ì˜ ê°’ì´ `undefined`, `null`, `0`ì´ ì•„ë‹ ë•ŒëŠ” `Maybe.Just(a / b)`ê°€ ë°˜í™˜ëœë‹¤.<br/>
í•˜ì§€ë§Œ ê·¸ ë°˜ëŒ€ë¡œ `undefined`, `null`, `0`ì¼ ë•ŒëŠ” `Maybe.Nothing`ì´ ë°˜í™˜ëœë‹¤.<br/>
ë”°ë¼ì„œ `divide` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ì•„ë˜ ì½”ë“œëŠ” ê°„ê²°í•˜ë©´ì„œë„ ì•ˆì •ì„±ì„ í•´ì¹˜ì§€ ì•Šê²Œëœë‹¤.<br/>

```typescript
import * as R from "ramda";

console.log(divide(1)(1).map(R.add(1)).getOrElse(0)); // 2
console.log(divide(1)(0).map(R.add(1)).getOrElse(0)); // 0
```

`divide(1)(1)`ëŠ” `Just(1 / 1)`ì´ ë°˜í™˜í•œ ê°’ì„ `R.add(1)`ì— ë”í•´ `2`ë¥¼ ì¶œë ¥í•˜ê²Œ ëœë‹¤.<br/>
`divide(1)(0)`ëŠ” `Nothing`ì„ ë°˜í™˜í•´ `R.add(1)`ê°€ ë™ì‘í•˜ì§€ ì•Šê³  `getOrElse(0)`ê°€ ë°˜í™˜í•œ `0`ì„ ì¶œë ¥í•œë‹¤.<br/>

### Maybe í´ë˜ìŠ¤ êµ¬ì¡°

`Maybe` í´ë˜ìŠ¤ëŠ” Typescript ì–¸ì–´ì˜ íŠ¹ì„±ì„ ê³ ë ¤í•´ ì•„ë˜ì™€ ê°™ì´ ì„¤ê³„í•œë‹¤.<br/>

-   `classes/Maybe.ts`

```typescript
import { Just } from "./Just";
import { Nothing } from "./Nothing";
import { IMonad } from "../interfaces";
import { _IMaybe } from "./_IMaybe";

export class Maybe<T> {
    static Just<U>(value: U) {
        return new Just<U>(value);
    }
    static Nothing = new Nothing();
}

export type IMaybe<T> = _IMaybe<T> & IMonad<T>;
```

ì‘ì„±ë˜ì§€ ì•Šì€ `Just`, `Nothing`, `_IMaybe`ëŠ” ì´í›„ì— êµ¬í˜„í•  ì˜ˆì •ì´ë‹¤.<br/>
`IMaybe<T>`ë¼ëŠ” íƒ€ì…ì„ ë‚´ë³´ë‚´ëŠ” ê²ƒì€ Typescript ì–¸ì–´ì˜ íŠ¹ì§•ì„ ë°˜ì˜í•œ ê²ƒì´ë‹¤.<br/>

### Maybeê°€ í•¨ìˆ˜ì˜ ë°˜í™˜ íƒ€ì…ì¼ ë•Œì˜ ë¬¸ì œì 

Typescript 3.7.4ë²„ì „ì€ `Just<number> | Nothing`ê³¼ ê°™ì€ í•©ì§‘í•© íƒ€ì…ì„ ë§Œë‚˜ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.<br/>

```typescript
import * as R from "ramda";
import { Just } from "../classes/Just";
import { Nothing } from "../classes/Nothing";
import { Maybe, IMaybe } from "../classes/Maybe";

const divide = (a: number) => (b: number): Just<number> | Nothing =>
    b ? Maybe.Just(a / b) : Maybe.Nothing;

console.log(divide(1)(1).map(R.add(1)).getOrElse(0)); // 2
console.log(divide(1)(0).map(R.add(1)).getOrElse(0)); // 0
```

-   ë°˜í™˜ íƒ€ì…ì´ `Just<number> | Nothing` ì¼ ë•Œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜

<img src="./images/4.png" width="450" height="auto">

í•˜ì§€ë§Œ ì•„ë˜ì™€ ê°™ì´ `IMaybe`ë¼ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ í•¨ìˆ˜ì˜ ë°˜í™˜ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ ì •ìƒ ì‘ë™í•œë‹¤.<br/>

```typescript
import * as R from "ramda";
import { Maybe, IMaybe } from "../classes/Maybe";

const divide = (a: number) => (b: number): IMaybe<number> =>
    b ? Maybe.Just(a / b) : Maybe.Nothing;

console.log(divide(1)(1).map(R.add(1)).getOrElse(0)); // 2
console.log(divide(1)(0).map(R.add(1)).getOrElse(0)); // 0
```

ë”°ë¼ì„œ `Maybe` í´ë˜ìŠ¤ëŠ” ì•„ë˜ `_IMaybe`ì™€ `IMonad` ì¸í„°í˜ì´ìŠ¤ë¥¼ í•©í•œ `IMaybe` íƒ€ì…ì„ ì œê³µí•œë‹¤.<br/>

-   `classes/_IMaybe.ts`

```typescript
export interface _IMaybe<T> {
    isJust(): boolean;
    isNothing(): boolean;
    getOrElse(defaultValue: T): T;
}
```

`Just`ì™€ `Nothing` í´ë˜ìŠ¤ ëª¨ë‘ `_IMaybe`ì™€ `IMonad`ë¥¼ êµ¬í˜„í•˜ê¸° ë•Œë¬¸ì— ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.<br/>

### Just ëª¨ë‚˜ë“œ êµ¬í˜„

`Just` ëª¨ë‚˜ë“œëŠ” `Identity` ëª¨ë‚˜ë“œì— `_IMaybe` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œë‹¤.<br/>

-   `classes/Just.ts`

```typescript
import { IMonad } from "../interfaces";
import { _IMaybe } from "./_IMaybe";

export class Just<T> implements _IMaybe<T>, IMonad<T> {
    constructor(private _value: T) {}
    value(): T {
        return this._value;
    }

    static of<T>(value: T): Just<T> {
        return new Just<T>(value);
    }

    isJust() {
        return true;
    }
    isNothing() {
        return false;
    }
    getOrElse<U>(defaultValue: U) {
        return this.value();
    }

    map<U, V>(fn: (x: T) => U): Just<U> {
        return new Just<U>(fn(this.value()));
    }

    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Just.of<U>((f as Function)(b));
        }
    }

    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

ë‹¤ë§Œ `Identity` ëª¨ë‚˜ë“œì™€ ë‹¬ë¦¬ `ISetoid` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ì§€ ì•ŠëŠ”ë‹¤.<br/>
ì´ëŠ” `Just`ê°€ `Nothing`ì¼ ë•Œë¥¼ ê³ ë ¤í•´ `value()`ê°€ ì•„ë‹Œ `getOrElse(0)` í˜•íƒœë¡œ ë™ì‘í•˜ê¸° ìœ„í•´ì„œë‹¤.<br/>

### Nothing ëª¨ë‚˜ë“œ êµ¬í˜„

`Nothing` ëª¨ë‚˜ë“œëŠ” `Just` ëª¨ë‚˜ë“œì™€ ë‹¬ë¦¬ ì½”ë“œë¥¼ ì™„ë²½í•˜ê²Œ ì‹¤í–‰ì‹œí‚¤ì§€ ì•ŠëŠ” ê²ƒì´ ëª©ì ì´ë‹¤.<br/>

-   `classes/Nothing.ts`

```typescript
import { IMonad } from "../interfaces";
import { _IMaybe } from "./_IMaybe";

export class Nothing implements _IMaybe<null>, IMonad<null> {
    static of<T>(value: T = null): Nothing {
        return new Nothing();
    }

    isJust() {
        return false;
    }
    isNothing() {
        return true;
    }
    getOrElse<U>(defaultValue: U) {
        return defaultValue;
    }

    map<U, V>(fn: (x) => U): Nothing {
        return new Nothing();
    }

    ap<U>(b: U) {
        return new Nothing();
    }

    chain<U>(fn: (T) => U): Nothing {
        return new Nothing();
    }
}
```

ìœ„ì˜ ì½”ë“œëŠ” `divide(1)(0).map(R.add(1))` í˜•íƒœì˜ ì½”ë“œê°€ ë¹„ì •ìƒì ìœ¼ë¡œ ë™ì‘í•˜ì§€ ì•Šê²Œ í•œë‹¤.<br/>
ë˜í•œ ê°€ì¥ ë§ˆì§€ë§‰ì— í˜¸ì¶œëœ `getOrElse(0)` ë©”ì„œë“œì˜ ê¸°ë³¸ê°’ì„ ë°˜í™˜í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œí•œë‹¤.<br/>

### Justì™€ Nothing ëª¨ë‚˜ë“œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

`Just`ëŠ” ì •ìƒì ì¼ ë•Œ ë™ì‘í•˜ëŠ” ëª¨ë‚˜ë“œì´ë¯€ë¡œ í•­ìƒ ì‹¤ì œê°’ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤.<br/>
ì•„ë˜ ì½”ë“œëŠ” `Just`ê°€ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•˜ë©° `_IMaybe` ì¸í„°í˜ì´ìŠ¤ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ê²ƒì„ ë³´ì—¬ì¤€ë‹¤.<br/>

-   `test/Just-Test.ts`

```typescript
import * as R from "ramda";
import { Just } from "../classes/Just";

console.log(Just.of(100).isJust()); // true
console.log(Just.of(100).isNothing()); // false
console.log(Just.of(100).getOrElse(1)); // 100
console.log(Just.of(100).map(R.identity).getOrElse(1)); // 100
console.log(Just.of(R.identity).ap(100).getOrElse(1)); // 100
console.log(Just.of(100).chain(Just.of).getOrElse(1)); // 100
```

`Nothing` ëª¨ë‚˜ë“œëŠ” `Just`ì™€ ë‹¬ë¦¬ ìì‹ ì˜ ëª¨ë‚˜ë“œ ê´€ë ¨ ì½”ë“œë¥¼ ë™ì‘ì‹œí‚¤ì§€ ë§ì•„ì•¼ í•œë‹¤.<br/>
ë˜í•œ `undefined`ë‚˜ `null`, `Nan`, `Infinity`ì™€ ê°™ì€ ê°’ì„ ë°˜í™˜í•´ì„œë„ ì•ˆëœë‹¤.<br/>

-   `test/Nothing-Test.ts`

```typescript
import { Nothing } from "../classes/Nothing";
import { Just } from "../classes/Just";

console.log(Nothing.of().isJust()); // false
console.log(Nothing.of().isNothing()); // true
console.log(Nothing.of().getOrElse(1)); // 1
console.log(
    Nothing.of()
        .map((x) => x + 1)
        .getOrElse(1)
); // 1
console.log(Nothing.of().ap(1).getOrElse(1)); // 1
console.log(Nothing.of().chain(Just.of).getOrElse(1)); // 1
```

ìœ„ì™€ ê°™ì´ `Nothing` ëª¨ë‚˜ë“œë¥¼ ì‚¬ìš©í•˜ë©´ `getOrElse`ë¡œ ë„˜ê²¨ì§„ ê¸°ë³¸ê°’ë§Œ ë°˜í™˜í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.<br/>

### Maybe í…ŒìŠ¤íŠ¸

ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ API ì„œë²„ì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ë•ŒëŠ” `fetch`ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤.<br/>
`fetch` í•¨ìˆ˜ëŠ” ì›¹ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì œê³µí•˜ì§€ë§Œ `Node.js` í™˜ê²½ì—ì„œëŠ” ì œê³µí•˜ì§€ ì•ŠëŠ”ë‹¤.<br/>
`node-fetch` íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•˜ë©´ `Node.js` í™˜ê²½ì—ì„œë„ `fetch`í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.<br/>
`fetch` í•¨ìˆ˜ëŠ” ì•„ë˜ì²˜ëŸ¼ ë¬¸ìì—´ë¡œ ëœ URLì„ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ë¡œ í˜¸ì¶œí•´ `Promise` ê°ì²´ë¥¼ ë°˜í™˜í•œë‹¤.<br/>

```typescript
fetch(url: string): Promise
```

`fetch`ê°€ ë°˜í™˜í•œ `Promise` ê°ì²´ëŠ” `then` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ ì‘ë‹µ ê°ì²´ ì–»ì„ ìˆ˜ ìˆë‹¤.<br/>
ì–»ì€ ì‘ë‹µ ê°ì²´ëŠ” `text`, `blob`, `json`ê³¼ ê°™ì€ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ ì‹¤ì œ ë°ì´í„°ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.<br/>
ì•„ë˜ ì½”ë“œëŠ” `fetch` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ `JSON` í¬ë§·ìœ¼ë¡œëœ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì˜ˆì‹œë‹¤.<br/>

-   `fetchJokes.ts`

```typescript
import fetch from "node-fetch";

export const fetchJokes = <T>() =>
    new Promise<T>((resolve, reject) => {
        const jokeUrl = "https://api.icndb.com/jokes/random/5?limitTo=[nerdy]";

        fetch(jokeUrl)
            .then((res) => res.json())
            .then((fetchResult: unknown) => resolve(fetchResult as T))
            .catch((e: Error) => reject(e));
    });
```

`jokeUrl` ë³€ìˆ˜ì— ë‹´ê¸´ í˜ì´ì§€ëŠ” `JSON` í¬ë§·ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë³´ë‚´ë¯€ë¡œ `json` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.<br/>
ì´ë ‡ê²Œ ì–»ì€ ì‹¤ì œ `JSON` ë°ì´í„°ëŠ” êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ `unknown`ìœ¼ë¡œ í•´ì„í•´ ì–»ëŠ”ë‹¤.<br/>
ì•„ë˜ì˜ ì½”ë“œë¥¼ í†µí•´ ì‘ì„±í•œ `fetchJokes` í•¨ìˆ˜ë¥¼ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆë‹¤.<br/>

-   `test/FetchJokes-Test.ts`

```typescript
import { fetchJokes } from "../fetchJokes";

fetchJokes()
    .then((result) => console.log(result))
    .catch((e: Error) => console.log(e.message));
```

ìœ„ì˜ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´ ì•„ë˜ì™€ ê°™ì€ í˜•íƒœì˜ `JSON` í¬ë§·ì˜ ë°ì´í„°ê°€ ì¶œë ¥ëœë‹¤.<br/>

<img src="./images/5.png" width="600" height="auto">

ìœ„ì˜ í™”ë©´ìœ¼ë¡œë¶€í„° ë°ì´í„°ëŠ” ì•„ë˜ì™€ ê°™ì€ í˜•íƒœì˜ íƒ€ì…ì„ ê°€ì§€ê³  ìˆìŒì„ ì•Œ ìˆ˜ ìˆë‹¤.<br/>

```typescript
{
    type: string,
    value: {
        id: number,
        joke: string,
        category: string[][]
    }
}
```

ì•„ë˜ ì½”ë“œëŠ” `fetchJokes` í•¨ìˆ˜ì˜ ê²°ê³¼ë¥¼ ê°€ê³µí•´ ë°ì´í„° ì¤‘ í•˜ë‚˜ë¥¼ ëœë¤í•˜ê²Œ ì„ íƒí•˜ê²Œ í•˜ëŠ” ì½”ë“œë‹¤.<br/>

-   `getRandomJoke.ts`

```typescript
import { fetchJokes } from "./fetchJokes";

const random = (max: number) => Math.floor(Math.random() * max);

export type FetchResult = { type: string; value: JokeType[] };
export type JokeType = {
    id: number;
    joke: string;
    category: string[];
};

export const getRandomJoke = () =>
    new Promise<JokeType>((resolve, reject) => {
        fetchJokes<FetchResult>()
            .then((result: FetchResult) => {
                let array: JokeType[] = result.value;
                resolve(array[random(array.length)]);
            })
            .catch((e: Error) => reject(e));
    });
```

ì•„ë˜ ì½”ë“œëŠ” ì‘ì„±í•œ `getRandomJoke` í•¨ìˆ˜ë¥¼ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì½”ë“œë‹¤.<br/>

-   `test/GetRandomJoke-Test.ts`

```typescript
import * as R from "ramda";
import { getRandomJoke, JokeType } from "../getRandomJoke";

getRandomJoke()
    .then((JokeItem: JokeType) => {
        const joke = R.view(R.lensProp("joke"))(JokeItem);
        console.log(joke);
    })
    .catch((e: Error) => console.log(e.message));
```

`ramda` ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ **ë Œì¦ˆ** ê¸°ëŠ¥ì„ ì‚¬ìš©í•´ `joke` ì†ì„±ê°’ë§Œ ì–»ì–´ ì¶œë ¥í•œë‹¤.<br/>
`getRandomJoke` í•¨ìˆ˜ëŠ” `then`ê³¼ `catch`ë¬¸ì„ ì‚¬ìš©í•´ ì½”ë“œê°€ ì¡°ê¸ˆ ë²ˆê±°ë¡­ë‹¤.<br/>
ì•„ë˜ì™€ ê°™ì´ `getRandomJoke` í•¨ìˆ˜ë¡œ ì–»ì€ ê°’ì„ `Maybe` ëª¨ë‚˜ë“œë¥¼ ì‚¬ìš©í•´ ê°€ê³µí•  ìˆ˜ ìˆë‹¤.<br/>

-   `getJokeAsMaybe.ts`

```typescript
import * as R from "ramda";
import { getRandomJoke, JokeType } from "./getRandomJoke";
import { IMaybe, Maybe } from "./classes/Maybe";

const _getJokeAsMaybe = async () => {
    const jokeItem: JokeType = await getRandomJoke();
    const joke = R.view(R.lensProp("joke"))(jokeItem);
    return joke;
};

export const getJokeAsMaybe = () =>
    new Promise<IMaybe<string>>((resolve, reject) => {
        _getJokeAsMaybe()
            .then((joke: string) => resolve(Maybe.Just(joke)))
            .catch((e) => resolve(Maybe.Nothing));
    });

export { IMaybe, Maybe };
```

ìœ„ì™€ ê°™ì´ êµ¬í˜„ëœ `getJokeAsMaybe`ëŠ” ì—ëŸ¬ê°€ ë°œìƒí•´ë„ `reject`ëŒ€ì‹  `Maybe.Nothing`ì„ ë°˜í™˜í•œë‹¤.<br/>
ì‘ì„±í•œ `getJokeAsMaybe` í•¨ìˆ˜ëŠ” ì•„ë˜ì™€ ê°™ì´ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆë‹¤.<br/>

-   `test/GetJokeAsMaybe-Test.ts`

```typescript
import { getJokeAsMaybe, IMaybe } from "../getJokeAsMaybe";

(async () => {
    const joke: IMaybe<string> = await getJokeAsMaybe();
    console.log(joke.getOrElse("something wrong"));
})();
```

ìœ„ì™€ ê°™ì´ `Maybe` ëª¨ë‚˜ë“œë¥¼ ì‚¬ìš©í•´ `then`, `catch` êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.<br/>
`Maybe` ëª¨ë‚˜ë“œëŠ” ì´ì²˜ëŸ¼ **ì˜¤ë¥˜ì¼ ë•Œì™€ ì •ìƒì¼ ë•Œë¥¼ ëª¨ë‘ ê³ ë ¤**í•˜ë©° **ê°„ê²°í•˜ê²Œ ì½”ë“œë¥¼ ì‘ì„±**í•  ìˆ˜ ìˆë‹¤.<br/>

[[ğŸ”ìœ„ë¡œê°€ê¸°]](#11ì¥-ëª¨ë‚˜ë“œ)&nbsp; / &nbsp;[[ğŸ”™ë’¤ë¡œê°€ê¸°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-4 Validation ëª¨ë‚˜ë“œ ì´í•´ì™€ êµ¬í˜„

### Validation ëª¨ë‚˜ë“œë€?

`Validation` ëª¨ë‚˜ë“œëŠ” **ë°ì´í„°ê°€ ìœ íš¨í•œì§€ íŒë‹¨**í•˜ëŠ” ìš©ë„ë¡œ ì„¤ê³„ëœ **ëª¨ë‚˜ë“œ**ë‹¤.<br/>
`Validation` ëª¨ë‚˜ë“œëŠ” **íŒíƒ€ì§€ëœë“œ ê·œê²©**ì˜ **ì–´í”Œë¼ì´** ê·œê²©ì— ì˜ì¡´í•´ ë™ì‘í•œë‹¤.<br/>
`Validation` ëª¨ë‚˜ë“œëŠ” `Success`ì™€ `Failure` ë‘ ê°€ì§€ ëª¨ë‚˜ë“œë¡œ êµ¬ì„±ëœë‹¤.<br/>
`Success`ì™€ `Failure` ëª¨ë‚˜ë“œëŠ” `Identity` ëª¨ë‚˜ë“œì˜ `ap` ë©”ì„œë“œ ë°©ì‹ìœ¼ë¡œ ë™ì‘í•œë‹¤.<br/>
`ap` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” `Identity` ëª¨ë‚˜ë“œì˜ `value`ê°€ í•¨ìˆ˜ì—¬ì•¼ í•œë‹¤.<br/>

-   `test/Ap-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const add = (a: number) => (b: number) => a + b;
console.log(add(1)(2)); // 3
console.log(Identity.of(add).ap(1).ap(2).value()); // 3
```

ìœ„ì˜ ì½”ë“œëŠ” `Identity`ì— **2ì°¨ ê³ ì°¨ í•¨ìˆ˜**ë¥¼ `value`ë¡œ í•œ ë’¤ `ap` ë©”ì„œë“œë¥¼ ë‘ ë²ˆ í˜¸ì¶œí•´ `3`ì„ ë§Œë“ ë‹¤.<br/>
ë˜í•œ **Nì°¨ ê³ ì°¨ í•¨ìˆ˜**ë¥¼ ì•„ë˜ì™€ ê°™ì´ ë§Œë“¤ ìˆ˜ ë„ ìˆë‹¤.<br/>

-   `getRandomJoke.ts`

```typescript
import { Identity } from "./classes/Identity";

type ISuccess = { isSuccess: boolean; isFailure: boolean };

const checkSuccess = (a: ISuccess) => (b: ISuccess): boolean =>
    [a, b].filter(({ isFailure }) => isFailure == true).length == 0;

const isSuccess = Identity.of(checkSuccess)
    .ap({
        isSuccess: true,
        isFailure: false,
    })
    .ap({ isSuccess: false, isFailure: true })
    .value();

console.log(isSuccess); // false
```

`checkSuccess` í•¨ìˆ˜ëŠ” ë‘ ê°œì˜ ê³ ì°¨ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°°ì—´ë¡œ ë§Œë“ ë‹¤.<br/>
ê·¸ í›„ `isFailure`ê°’ì´ `true`ì¸ ê²ƒë“¤ë§Œ ì¶”ë ¤ë‚´ ê°œìˆ˜ê°€ `0`ì¼ ë•Œë§Œ ì„±ê³µì´ë¼ê³  íŒë‹¨í•œë‹¤.<br/>
`Validation` í´ë˜ìŠ¤ê°€ ì œê³µí•˜ëŠ” `Success`ì™€ `Failure` ëª¨ë‚˜ë“œëŠ” ì´ëŸ° ë°©ì‹ìœ¼ë¡œ ë™ì‘í•œë‹¤.<Br/>

### Validation í´ë˜ìŠ¤ êµ¬ì¡°

`Validation` ëª¨ë‚˜ë“œëŠ” `Maybe`ì™€ ë¹„ìŠ·í•˜ê²Œ `Success`ì™€ `Failure` ë‘ ê°€ì§€ë¡œ êµ¬ì„±ëœë‹¤.<br/>
`Success`ì™€ `Failure`ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë°ì´í„°ì˜ **ìœ íš¨ì„± ê²€ì¦ ìƒíƒœë¥¼ íŒë‹¨í•´ ë™ì‘**í•œë‹¤.<br/>

-   `classes/Validation.ts`

```typescript
import { Success } from "./Success";
import { Failure } from "./Failure";

export class Validation {
    static Success = Success;
    static Failure = Failure;
    static of<T>(fn: T): Success<T> {
        return Success.of<T>(fn);
    }
}

export { Success, Failure };
```

-   `classes/IValidation.ts`

```typescript
export interface IValidation<T> {
    isSuccess: boolean;
    isFailure: boolean;
}
```

`Success`ì™€ `Failure` ëª¨ë‚˜ë“œëŠ” ìœ„ì˜ `IValidation` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œë‹¤.<br/>

### Success ëª¨ë‚˜ë“œ êµ¬í˜„

`Success` ëª¨ë‚˜ë“œëŠ” `IChain` í˜•íƒœë¡œëŠ” ë™ì‘í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ `IFunctor`, `IApply`, `IApplicative`ë§Œ êµ¬í˜„í•œë‹¤.<br/>

-   `classes/Success.ts`

```typescript
import { IApplicative } from "../interfaces";
import { IValidation } from "./IValidation";

export class Success<T> implements IValidation<T>, IApplicative<T> {
    constructor(
        public value: T,
        public isSuccess = true,
        public isFailure = false
    ) {}

    static of<U>(value: U): Success<U> {
        return new Success<U>(value);
    }

    map<U>(fn: (x: T) => U) {
        return new Success<U>(fn(this.value));
    }

    ap(b) {
        return b.isFailure ? b : b.map(this.value);
    }
}
```

`ap` ë©”ì„œë“œëŠ” ë§¤ê°œë³€ìˆ˜ê°€ `Failure`ì¸ì§€ì— ë”°ë¼ ì¡°ê¸ˆ ë‹¤ë¥´ê²Œ ë™ì‘í•œë‹¤.<br/>
`Success`ì˜ `value`ëŠ” í•¨ìˆ˜ì´ë¯€ë¡œ `b.map(this.value)`ê°™ì´ `map` í•¨ìˆ˜ì˜ ì½œë°± í•¨ìˆ˜ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤.<br/>
ì•„ë˜ì˜ ì½”ë“œë¡œ ì‘ì„±í•œ `Success` í´ë˜ìŠ¤ë¥¼ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆë‹¤.<br/>

-   `test/Success-Test.ts`

```typescript
import { Success } from "../classes/Success";

const checkSuccess = <T>(a: Success<T>) => (b: Success<T>): boolean =>
    [a, b].filter(({ isFailure }) => isFailure == true).length == 0;

console.log(Success.of(checkSuccess).ap(Success.of(1)).ap(Success.of(2)));
// Success { value: true, isSuccess: true, isFailure: false }
```

`checkSuccess`ê°€ ìµœì¢…ì ìœ¼ë¡œ `boolean` íƒ€ì… ê°’ì„ ë°˜í™˜í•˜ë¯€ë¡œ ìµœì¢… `Success` ê°ì²´ì˜ `value`ëŠ” `true`ë‹¤.<br/>

### Failure ëª¨ë‚˜ë“œ êµ¬í˜„

`Failure` ëª¨ë‚˜ë“œëŠ” ìµœì¢…ì ìœ¼ë¡œ ì‹¤íŒ¨í•œ ì›ì¸ì„ ë¬¸ìì—´ ë°°ì—´ë¡œ ì €ì¥í•œë‹¤.<br/>

-   `classes/Failure.ts`

```typescript
import { IValidation } from "./IValidation";
import { IApplicative } from "../interfaces";

export class Failure<T> implements IValidation<T>, IApplicative<T> {
    constructor(
        public value: T[],
        public isSuccess = false,
        public isFailure = true
    ) {}

    static of<U>(value: U[]): Failure<U> {
        return new Failure<U>(value);
    }

    map(fn) {
        return new Failure<T>(fn(this.value));
    }

    ap(b) {
        return b.isFailure ? new Failure<T>([...this.value, ...b.value]) : this;
    }
}
```

`Failure`ì˜ `ap` ë©”ì„œë“œì—ì„œ ê¸°ì¡´ ì—ëŸ¬ ë¬¸ìì—´ ë°°ì—´ì— í˜„ì¬ ì—ëŸ¬ ë¬¸ìì—´ ë°°ì—´ì„ **ì „ê°œ ì—°ì‚°ìë¡œ ë³‘í•©**í•œë‹¤.<br/>

### ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ ê¸°ëŠ¥ êµ¬í˜„

ë¹„ë°€ë²ˆí˜¸ë¥¼ ê²€ì¦í•˜ê¸° ìœ„í•´ì„œëŠ” ê°ì²´ì—ëŠ” `string` íƒ€ì…ì˜ `password` ì†ì„±ì´ ìˆì–´ì•¼í•œë‹¤.<br/>
ì•„ë˜ì˜ `checkNull` í•¨ìˆ˜ëŠ” ì´ëŸ° ë‚´ìš©ì„ ê²€ì¦í•œë‹¤.<br/>

-   `utils/checkNull.ts`

```typescript
import { Success, Failure } from "../classes/Validation";

export const checkNull = <S, F>(o: { password?: string }) => {
    const { password } = o;

    return password == undefined || typeof password != "string"
        ? new Failure(["Password can not be null"])
        : new Success(o);
};
```

ë¬¸ìì—´ì˜ ê¸¸ì´ê°€ ìµœì†Œ 6ì ì´ìƒì´ì–´ì•¼ í•œë‹¤ëŠ” ê²€ì¦ì€ ì•„ë˜ì˜ `checkLength` í•¨ìˆ˜ë¡œ êµ¬í˜„í•œë‹¤.<br/>

-   `utils/checkLength.ts`

```typescript
import { Success, Failure } from "./../classes/Validation";

export const checkLength = (
    o: { password?: string },
    minLength: number = 6
) => {
    const { password } = o;
    return !password || password.length < minLength
        ? new Failure([`Password must have more than ${minLength} characters`])
        : new Success(o);
};
```

ë¹„ë°€ë²ˆí˜¸ ìœ íš¨ì„± ê²€ì¦ì€ `checkNull`ì™€ `checkLength`ê°€ ëª¨ë‘ `Success`ë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ íŒë³„í•´ì•¼í•œë‹¤.<br/>
ì•„ë˜ ì½”ë“œì˜ `checkPassword`ëŠ” ì´ëŸ¬í•œ ë‚´ìš©ì„ êµ¬í˜„í•œ ì˜ˆì‹œë‹¤.<br/>

-   `checkPassword.ts`

```typescript
import { Validation } from "./classes/Validation";
import { checkNull } from "./utils/checkNull";
import { checkLength } from "./utils/checkLength";

export const checkPassword = (o): [object, string[]] => {
    const result = Validation.of((a) => (b) => o)
        .ap(checkNull(o))
        .ap(checkLength(o));

    return result.isSuccess
        ? [result.value, undefined]
        : [undefined, result.value];
};
```

ì•„ë˜ì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œë¡œ ì‘ì„±í•œ `checkPassword` í•¨ìˆ˜ì˜ ë™ì‘ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.<br/>

-   `test/CheckPassword-Test.ts`

```typescript
import { checkPassword } from "../checkPassword";

[{ password: "123456" }, { password: "1234" }, {}, { pa: "123456" }].forEach(
    (target, index) => {
        const [value, failureReason] = checkPassword(target);

        if (failureReason) {
            console.log(
                index,
                `validation fail.`,
                JSON.stringify(failureReason)
            );
        } else {
            console.log(index, `validation ok.`, JSON.stringify(value));
        }
    }
);
```

-   `CheckPassword-Test.ts` ì‹¤í–‰ ê²°ê³¼

<img src="./images/6.png" width="600" height="auto">

`{ password: '123456' }`ê³¼ ê°™ì€ ì •ìƒì ì¸ ë¹„ë°€ë²ˆí˜¸ì¼ ê²½ìš° `validation ok.` ë©”ì‹œì§€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.<br/>
ë°˜ë©´ì— `{}`ë‚˜ `{ pa: '123456' }`ê³¼ ê°™ì´ ê²€ì¦ì´ ì‹¤íŒ¨í•œ ê²½ìš° ê²€ì¦ì— ì‹¤íŒ¨í•œ ì´ìœ ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.<br/>

### ì´ë©”ì¼ ì£¼ì†Œ ê²€ì¦ ê¸°ëŠ¥ êµ¬í˜„

ì´ë©”ì¼ ì£¼ì†Œì²˜ëŸ¼ ì–´ë–¤ ì¼ì •í•œ íŒ¨í„´ì´ ìˆì„ ë•ŒëŠ” **ì •ê·œì‹**ì„ ì‚¬ìš©í•´ ìœ íš¨ì„±ì„ íŒë³„í•œë‹¤.<br/>
ì•„ë˜ì˜ ì½”ë“œëŠ” **ì •ê·œì‹**ì„ ì´ìš©í•´ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ê²€ì¦í•˜ëŠ” í•¨ìˆ˜ë‹¤.<br/>

-   `utils/checkEmailAddress.ts`

```typescript
import { Success, Failure } from "../classes/Validation";

export const checkEmailAddress = (o: { email?: string }) => {
    const { email } = o;

    const re = new RegExp(
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
    );

    return re.test(email)
        ? new Success(email)
        : new Failure(["Invalid email address"]);
};
```

`checkEmail` í•¨ìˆ˜ëŠ” `checkEmailAddress` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ë°ì´í„° ìœ íš¨ì„±ì„ íŒë³„í•˜ë„ë¡ êµ¬í˜„ë˜ì—ˆë‹¤.<br/>

-   `checkEmail.ts`

```typescript
import { Validation } from "./classes/Validation";
import { checkEmailAddress } from "./utils/checkEmailAddress";

export const checkEmail = (o): [object, string[]] => {
    const result = Validation.of((a) => o).ap(checkEmailAddress(o));

    return result.isSuccess
        ? [result.value, undefined]
        : [undefined, result.value];
};
```

`checkPassword`ì™€ ë‹¬ë¦¬ `email` ì†ì„±ì´ `null`ì¸ì§€ íŒë³„í•˜ì§€ ì•ŠëŠ”ë‹¤.<br/>
ë”°ë¼ì„œ `Validation.of`ì— 1ì°¨ í•¨ìˆ˜ê°€ ì ìš©ë˜ë©° `ap` ë©”ì„œë“œ ë˜í•œ í•œ ë²ˆë§Œ í˜¸ì¶œëœë‹¤.<br/>
ì•„ë˜ì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œë¡œ ì‘ì„±í•œ `checkEmail` í•¨ìˆ˜ì˜ ë™ì‘ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.<br/>

-   `test/CheckEmail-Test.ts`

```typescript
import { checkEmail } from "../checkEmail";

[{ email: "abc@efg.com" }, { email: "abcefg" }].forEach((target, index) => {
    const [value, failureReason] = checkEmail(target);

    if (failureReason) {
        console.log(index, "validation fail.", JSON.stringify(failureReason));
    } else {
        console.log(index, "validation ok.", JSON.stringify(value));
    }
});
```

-   `CheckEmail-Test.ts` ì‹¤í–‰ ê²°ê³¼

<img src="./images/7.png" width="350" height="auto">

ìœ„ì™€ ê°™ì´ `abc@efg.com`ì€ ê²€ì¦ì— ì„±ê³µí–ˆì§€ë§Œ `abcdef`ì™€ ê°™ì€ ë‹¨ìˆœ ë¬¸ìì—´ì€ í‹€ë¦° ì£¼ì†Œë¡œ íŒë³„í•œë‹¤.<br/>

[[ğŸ”ìœ„ë¡œê°€ê¸°]](#11ì¥-ëª¨ë‚˜ë“œ)&nbsp; / &nbsp;[[ğŸ”™ë’¤ë¡œê°€ê¸°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-5 IO ëª¨ë‚˜ë“œ ì´í•´ì™€ êµ¬í˜„

[[ğŸ”ìœ„ë¡œê°€ê¸°]](#11ì¥-ëª¨ë‚˜ë“œ)&nbsp; / &nbsp;[[ğŸ”™ë’¤ë¡œê°€ê¸°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
