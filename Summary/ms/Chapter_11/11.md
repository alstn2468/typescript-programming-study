# 11μ¥ λ¨λ‚λ“

<details><summary>Table of Contents</summary>

-   11-1 λ¨λ‚λ“ μ΄ν•΄ν•κΈ° [:link:](#11-1-λ¨λ‚λ“-μ΄ν•΄ν•κΈ°)
    -   νƒ€μ… ν΄λμ¤λ€? [:link:](#νƒ€μ…-ν΄λμ¤λ€)
    -   κ³ μ°¨ νƒ€μ…μ΄λ€? [:link:](#κ³ μ°¨-νƒ€μ…μ΄λ€)
    -   μΉ΄ν…κ³ λ¦¬ μ΄λ΅ μ΄λ€? [:link:](#μΉ΄ν…κ³ λ¦¬-μ΄λ΅ μ΄λ€)
    -   ννƒ€μ§€λλ“ κ·κ²© [:link:](#ννƒ€μ§€λλ“-κ·κ²©)
    -   λ¨λ‚λ“ λ£° [:link:](#λ¨λ‚λ“-λ£°)
-   11-2 Identity λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„ [:link:](#11-2-identity-λ¨λ‚λ“-μ΄ν•΄μ™€-κµ¬ν„)
    -   ν”„λ΅μ νΈ κµ¬μ„± [:link:](#ν”„λ΅μ νΈ-κµ¬μ„±)
    -   κ°’ μ»¨ν…μ΄λ„ κµ¬ν„μ© IValuable\<T> μΈν„°νμ΄μ¤ κµ¬ν„ [:link:](#κ°’-μ»¨ν…μ΄λ„-κµ¬ν„μ©-ivaluablet-μΈν„°νμ΄μ¤-κµ¬ν„)
    -   ν΄λμ¤ μ΄λ¦„μ΄ μ™ Identity μΈκ°€? [:link:](#ν΄λμ¤-μ΄λ¦„μ΄-μ™-identity-μΈκ°€)
    -   κ°’ μ»¨ν…μ΄λ„λ΅μ„μ Identity\<T> κµ¬ν„ν•κΈ° [:link:](#κ°’-μ»¨ν…μ΄λ„λ΅μ„μ-identityt-κµ¬ν„ν•κΈ°)
    -   ISetoid\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#isetoidt-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   IFunctor\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#ifunctort-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   μ—”λ„ν‘ν„°λ€? [:link:](#μ—”λ„ν‘ν„°λ€)
    -   IApply\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#iapplyt-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   IApplicative\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#iapplicativet-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   IChian\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#ichiant-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   IMonad\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#imonadt-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
-   11-3 Maybe λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„ [:link:](#11-3-maybe-λ¨λ‚λ“-μ΄ν•΄μ™€-κµ¬ν„)
-   11-4 Validation λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„ [:link:](#11-4-validation-λ¨λ‚λ“-μ΄ν•΄μ™€-κµ¬ν„)
-   11-5 IO λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„ [:link:](#11-5-io-λ¨λ‚λ“-μ΄ν•΄μ™€-κµ¬ν„)

</details>

## 11-1 λ¨λ‚λ“ μ΄ν•΄ν•κΈ°

### νƒ€μ… ν΄λμ¤λ€?

**νƒ€μ… ν΄λμ¤**μ ν•„μ”μ„±μ„ μ΄ν•΄ν•λ” κ²ƒμ€ **λ¨λ‚λ“**λ¥Ό μ΄ν•΄ν•κΈ° μ„ν•΄ μ¤‘μ”ν•λ‹¤.<br/>
μ•„λμ 2μ°¨ κ³ μ°¨ ν•¨μ `callMap`μ€ κ³ μ°¨ λ§¤κ°λ³€μ `b`κ°€ `map` λ©”μ„λ“λ¥Ό κ°€μ΅λ‹¤λ” κ°€μ •μΌλ΅ κµ¬ν„λμ—λ‹¤.<br/>

```typescript
const callMap = (fn) => (b) => b.map(fn);
```

λ”°λΌμ„ μ•„λμ™€ κ°™μ€ μ½”λ“λ¥Ό μ‚¬μ©ν•λ©΄ μ •μƒμ μΌλ΅ μ‘λ™ν•λ‹¤.<br/>

```typescript
callMap((a) => a + 1)([1]);
```

ν•μ§€λ§ μ•„λμ™€ κ°™μ΄ μ‘μ„±μ‹ ν”„λ΅κ·Έλ¨μ΄ λΉ„μ •μƒμ μΌλ΅ μΆ…λ£λλ‹¤.<br/>

```typescript
callMap((a) => a + 1)(1);
```

μ΄λ¥Ό λ°©μ§€ν•λ ¤λ©΄ μ•„λμ²λΌ λ§¤κ°λ³€μ `b`λ” λ°λ“μ‹ `map` λ©”μ„λ“κ°€ μλ” νƒ€μ…μΌλ΅ μ ν•ν•΄μ•Ό ν•λ‹¤.<br/>

```typescript
const callMap = <T, U>(fn: (T) => U) => <T extends { map(fn) }>(b: T) =>
    b.map(fn);
```

μ•„λμ™€ κ°™μ΄ `map` λ©”μ„λ“κ°€ μ—†λ” `1`μ€ κ³ μ°¨ λ§¤κ°λ³€μλ΅ μ‚¬μ©ν•  μ μ—†λ‹¤.<br/>

<img src="./images/1.png" width="500" height="auto">

λ”°λΌμ„ μ½”λ“λ¥Ό μ‘μ„±ν•λ” μ‹μ μ— ν”„λ΅κ·Έλ¨μ΄ λΉ„μ •μƒμ μΌλ΅ μ •λ£λλ” κ²ƒμ„ λ§‰μ„ μ μλ‹¤.<br/>
λ³΄ν†µ κ°μ²΄μ§€ν–¥ μ–Έμ–΄λΌλ©΄ `map` λ©”μ„λ“λ¥Ό κ°–λ” `Number` ν΄λμ¤λ¥Ό κµ¬ν„ν•λ” μ‹μΌλ΅ μ„¤κ³„ν•  κ²ƒμ΄λ‹¤.<br/>
ν•μ§€λ§ **λ¨λ‚λ“** λ°©μ‹ μ„¤κ³„λ” λ°λ“μ‹ `map`κ³Ό `of`λΌλ” λ©”μ„λ“κ°€ μλ” `Monad<T>` ν΄λμ¤λ¥Ό λ§λ“ λ‹¤.<br/>

```typescript
class Monad<T> {
    constructor(public value: T) {}
    static of<U>(value: U): Monad<U> {
        return new Monad<U>(value);
    }
    map<U>(fn: (x: T) => U): Monad<U> {
        return new Monad<U>(fn(this.value));
    }
}
```

μ΄μ²λΌ `Monad<T>`μ™€ κ°™μ€ ν΄λμ¤λ¥Ό **νƒ€μ… ν΄λμ¤**λΌκ³  ν•λ‹¤.<br/>
**νƒ€μ… ν΄λμ¤**λ” λ‹¤μμ²λΌ ν•¨μλ¥Ό λ§λ“¤ λ• νΉλ³„ν• νƒ€μ…μΌλ΅ μ μ•½ν•μ§€ μ•μ•„λ„ λλ‹¤.<br/>

```typescript
const callMonad = (fn) => (b) => Monad.of(b).map(fn).value;
```

**νƒ€μ… ν΄λμ¤** λ•λ¶„μ— **νƒ€μ…μ— λ”°λ¥Έ μ•μ •μ„±μ„ λ³΄μ¥**ν•κ³  μ½”λ“μ **μ¬μ‚¬μ©μ„±μ΄ λ›°μ–΄λ‚ λ²”μ© ν•¨μ**λ¥Ό μ‰½κ² λ§λ“¤ μ μλ‹¤.<br/>

```typescript
callMonad((a: number) => a + 1)(1); // 2
callMonad((a: number[]) => a.map((value) => value + 1))([1, 2, 3, 4]); // [ 2, 3, 4, 5 ]
```

`callMonad`μ™€ κ°™μ€ ν•¨μλ” ν• λ²λ§ λ§λ“¤λ©΄ μ„μ²λΌ **λ§¤κ°λ³€μμ νƒ€μ…μ— λ¬΄κ΄€**ν• κ°„κ²°ν• μ½”λ“λ¥Ό μ‘μ„±ν•  μ μλ‹¤.<br/>

### κ³ μ°¨ νƒ€μ…μ΄λ€?

`Monad<T>`λ” νƒ€μ… `T`λ¥Ό `Monad<T>`λ΅ λ³€ν™ν–λ‹¤ λ‹¤μ‹ νƒ€μ… `T`λ΅ λ³€ν™ν•΄μ¤€λ‹¤.<br/>
`Monad<T>`μ™€ κ°™μ΄ νƒ€μ… `T`λ¥Ό ν• λ‹¨κ³„ λ” λ†’μ€ νƒ€μ…μΌλ΅ λ³€ν™ν•λ” μ©λ„μ νƒ€μ…μ„ **κ³ μ°¨ νƒ€μ…**μ΄λΌ ν•λ‹¤.<br/>
**κ³ μ°¨ νƒ€μ…**μ€ **μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ΄λΌλ” μν•™μ—μ„ μ•„μ΄λ””μ–΄λ¥Ό μ–»μ—λ‹¤.<br/>
Typescriptμ—μ„λ” `Monad<T>`μ™€ κ°™μ΄ **2μ°¨ κ³ μ°¨ νƒ€μ…**μ„ λ§λ“¤ μ μκ² ν•λ” κµ¬λ¬Έμ„ μ κ³µν•λ‹¤.<br/>
ν•μ§€λ§ μ¤μΉΌλΌ μ–Έμ–΄μ²λΌ `Functor[F[_]]` κ°™μ€ 3μ°¨ μ΄μƒμ κ³ μ°¨ νƒ€μ…μ€ λ§λ“¤ μ μ—†λ‹¤.<br/>

### μΉ΄ν…κ³ λ¦¬ μ΄λ΅ μ΄λ€?

**μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ€ 1940λ…„μ— μ‹μ‘λ μν•™μ ν• λ¶„μ•Όλ΅ ν•¨μν• ν”„λ΅κ·Έλλ° μ–Έμ–΄μ μ¤‘μ”ν• μ΄λ΅ μ μΈ λ°°κ²½μ΄ λμ—λ‹¤.<br/>
**μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ€ ν”ν μ•„λμ κ·Έλ¦ΌμΌλ΅ ν‘ν„λλ‹¤.<br/>

<img src="./images/2.png" width="500" height="auto">

μν•™μ—μ„ **μ§‘ν•©**μ€ ν”„λ΅κ·Έλλ°μ—μ„μ **νƒ€μ…**μ΄λ‹¤.<br/>
μν•™μ—μ„ **μΉ΄ν…κ³ λ¦¬**λ” **μ§‘ν•©μ μ§‘ν•©**μΌλ΅ μ΄ν•΄ν•  μ μλ‹¤.<br/>
λ”°λΌμ„ ν”„λ΅κ·Έλλ°μ—μ„μ **μΉ΄ν…κ³ λ¦¬**λ” **νƒ€μ…μ νƒ€μ…**μΌλ΅ **κ³ μ°¨ νƒ€μ…**μΌλ΅ μ΄ν•΄ν•  μ μλ‹¤.<br/>
λν• **λ¨λ‚λ“**λ” λ³„λ„μ νΉμ§•μ΄ μλ” **κ³ μ°¨ νƒ€μ…**μ΄λ‹¤.<br/>

### ννƒ€μ§€λλ“ κ·κ²©

**λ¨λ‚λ“**λ” ν•μ¤μΌ μ–Έμ–΄μ `Prelude`λΌλ” ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬μ—μ„ μ‚¬μ©λλ” μ©μ–΄μ΄κΈ°λ„ ν•λ‹¤.<br/>
**λ¨λ‚λ“**λ” **λ¨λ‚λ“ λ£°**μ΄λΌκ³  ν•λ” μ½”λ“ μ„¤κ³„ μ›μΉ™μ— λ§μ¶° κµ¬ν„λ ν΄λμ¤λ¥Ό μλ―Έν•λ‹¤.<br/>
μ•„λ κ·Έλ¦Όμ€ Githubμ— μλ” [ννƒ€μ§€λλ“ κ·κ²©](https://github.com/fantasyland/fantasy-land)μ— μλ” κ·Έλ¦Ό μ¤‘ λ¶€λ¶„μ΄λ‹¤.<br/>

<img src="./images/3.png" width="550" height="auto">

ννƒ€μ§€λλ“ κ·κ²©μ€ ν•μ¤μΌ ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬ κµ¬μ΅°λ¥Ό Javascript λ°©μ‹μΌλ΅ μ¬κµ¬μ„±ν• κ²ƒμ΄λ‹¤.<br/>
κ·Έλ¦Όμ—μ„ λ³΄λ©΄ **λ¨λ‚λ“**λ” μ•„λ λ„¤ κ°€μ§€ μ”μ†λ¥Ό κµ¬ν„ν• κ²ƒμ„μ„ μ• μ μλ‹¤.<br/>

-   **ν‘ν„°**(**Functor**) : `map`μ΄λΌλ” μΈμ¤ν„΄μ¤ λ©”μ„λ“λ¥Ό κ°€μ§€λ” ν΄λμ¤
-   **μ–΄ν”λΌμ΄**(**Apply**) : **ν‘ν„°**μ΄λ©΄μ„ `ap`λΌλ” μΈμ¤ν„΄μ¤ λ©”μ„λ“λ¥Ό κ°€μ§€λ” ν΄λμ¤
-   **μ• ν”λ¦¬μ»¤ν‹°λΈ**(**Applicative**) : **μ–΄ν”λΌμ΄**μ΄λ©΄μ„ `of`λΌλ” ν΄λμ¤ λ©”μ„λ“λ¥Ό κ°€μ§€λ” ν΄λμ¤
-   **μ²΄μΈ**(**Chain**) : **μ• ν”λ¦¬μ»¤ν‹°λΈ**μ΄λ©΄μ„ `chain`μ΄λΌλ” λ©”μ„λ“λ¥Ό κ°€μ§€λ” ν΄λμ¤

μ–΄λ–¤ ν΄λμ¤κ°€ μ„μ λ„¤ κ°€μ§€ μ΅°κ±΄μ„ λ¨λ‘ λ§μ΅±ν•λ‹¤λ©΄ κ·Έ ν΄λμ¤λ” **λ¨λ‚λ“**λ‹¤.<br/>

### λ¨λ‚λ“ λ£°

ν΄λμ¤ μ΄λ¦„μ΄ `M`μ΄κ³  μΈμ¤ν„΄μ¤λ¥Ό `m`μ΄λΌκ³  ν• λ• **λ¨λ‚λ“**λ” **μ• ν”λ¦¬μ»¤ν‹°λΈ**μ™€ **μ²΄μΈ**μ κΈ°λ¥μ„ κ°–λ”λ‹¤.<br/>
λν• ν•΄λ‹Ή **λ¨λ‚λ“** ν΄λμ¤λ” μ•„λμ™€ κ°™μ€ λ‘ κ°€μ§€ λ²•μΉ™μ„ λ§μ΅±ν•λ‹¤.<br/>

|             κµ¬λ¶„             |            μλ―Έ            |
| :--------------------------: | :------------------------: |
|  μ™Όμ½ λ²•μΉ™ (Left Identity)   | `M.of(a).chain(f) == f(a)` |
| μ¤λ¥Έμ½ λ²•μΉ™ (Right Identity) |    `m.chain(M.of) == m`    |

ν•μ¤μΌμ `Prelude` ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬λ” `Maybe`μ™€ κ°™μ€ λ―Έλ¦¬ κµ¬ν„λ **λ¨λ‚λ“**λ¥Ό μ κ³µν•λ‹¤.<br/>
Typescriptλ” **λ¨λ‚λ“** λΌμ΄λΈλ¬λ¦¬λ¥Ό μ κ³µν•μ§€ μ•μΌλ―€λ΅ **ννƒ€μ§€λλ“ κ·κ²©**μ— λ§μ¶° μ‘μ„±ν•΄μ•Ό ν•λ‹¤.<br/>

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-2 Identity λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„

### ν”„λ΅μ νΈ κµ¬μ„±

μ•„λμ™€ κ°™μ΄ Typescriptλ¥Ό μ‚¬μ©ν•λ” node.js ν”„λ΅μ νΈλ¥Ό κµ¬μ„±ν•λ‹¤.<br/>

```shell
> npm init --y
> npm i -D typescript ts-node @types/node
> mkdir -p src/test
> mkdir src/interfaces
> mkdir src/classes
```

`tsconfig.json` νμΌμ€ μ•„λμ™€ κ°™μ΄ μ„¤μ •ν•λ‹¤.<br/>

```typescript
{
    "compilerOptions": {
        "module": "CommonJS",
        "esModuleInterop": true,
        "target": "es5",
        "moduleResolution": "node",
        "outDir": "dist",
        "baseUrl": ".",
        "sourceMap": true,
        "downlevelIteration": true,
        "noImplicitAny": false,
        "paths": {
            "*": ["node_modules/*"]
        }
    },
    "include": ["src/**/*"]
}
```

κΈ°μ΅΄μ— μ‚¬μ©ν–λ `tsconfig.json` νμΌ μ„¤μ •λ“¤κ³Ό λ™μΌν•κ² μ„¤μ •ν•μ€λ‹¤.<br/>

### κ°’ μ»¨ν…μ΄λ„ κµ¬ν„μ© IValuable\<T> μΈν„°νμ΄μ¤ κµ¬ν„

μ–΄λ–¤ νƒ€μ… `T`κ°€ μμ„ λ• λ°°μ—΄ `T[]`λ” κ°™μ€ νƒ€μ…μ μ•„μ΄ν…μ„ μ—¬λ¬ κ° κ°€μ§„ **μ»¨ν…μ΄λ„**λ‹¤.<br/>
λ³΄ν†µ **μ»¨ν…μ΄λ„**λΌλ” μ©μ–΄λ” μ΄μ²λΌ ν”ν **λ°°μ—΄**μ„ μλ―Έν•λ‹¤.<br/>
ν•μ§€λ§ `Monad<T>`μ²λΌ **λ°°μ—΄μ΄ μ•„λ‹ ν• κ°μ κ°’μ„ κ°€μ§€λ” μ»¨ν…μ΄λ„ ν΄λμ¤**λ¥Ό μƒκ°ν•  μ μλ‹¤.<br/>
μ΄ **μ»¨ν…μ΄λ„ ν΄λμ¤**λ” λ¨λ“  νƒ€μ… `T`μ κ°’μ„ κ°€μ§ μ μλ” **μ λ„¤λ¦­ μ»¨ν…μ΄λ„ ν΄λμ¤**λ‹¤.<br/>
μ΄μ²λΌ νƒ€μ… `T`λ¥Ό κ°€μ§€λ” κ°’μ μ»¨ν…μ΄λ„λ¥Ό **κ°’ μ»¨ν…μ΄λ„**λΌκ³  ν•λ‹¤.<br/>
**κ°’ μ»¨ν…μ΄λ„**λ¥Ό κµ¬ν„ν•κΈ° μ„ν•΄ μ•„λμ `IValuable<T>` μΈν„°νμ΄μ¤λ¥Ό μ‘μ„±ν•λ‹¤.<br/>

-   `interfaces/IValuable.ts`

```typescript
export interface IValuable<T> {
    value(): T;
}
```

λν• μ•μΌλ΅ `Identity<T>`μ μ½”λ“λ¥Ό νΈν•κ² μ‚¬μ©ν•κ³ μ μ•„λμ λ‚΄μ©μ `index.ts`λ¥Ό μ‘μ„±ν•λ‹¤.<br/>

-   `interfaces/index.ts`

```typescript
import { IValuable } from "./IValuable";
import { ISetoid } from "./ISetoid";
import { IFunctor } from "./IFunctor";
import { IApplicative } from "./IApplicative";
import { IApply } from "./IApply";
import { IChain } from "./IChain";
import { IMonad } from "./IMonad";

export { IValuable, ISetoid, IFunctor, IApplicative, IApply, IChain, IMonad };
```

### ν΄λμ¤ μ΄λ¦„μ΄ μ™ Identity μΈκ°€?

**ν•¨μν• ν”„λ΅κ·Έλλ°**μ—μ„ `identity`λ” ν•­μƒ μ•„λμ²λΌ κµ¬ν„ν•λ” νΉλ³„ν• μλ―Έμ ν•¨μλ‹¤.<br/>

```typescript
const identity = <T>(value: T): T => value;
```

μ•μ—μ„ λ³Έ `ramda` λΌμ΄λΈλ¬λ¦¬μ `R.identity` ν•¨μκ°€ `identity`λ¥Ό κµ¬ν„ν•κ³  μλ‹¤.<br/>
`Identity`λ” `map`, `ap`, `of`, `chain`κ³Ό κ°™μ€ κΈ°λ³Έ λ©”μ„λ“λ§ κµ¬ν„ν• **λ¨λ‚λ“**λ‹¤.<br/>
**μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ—μ„ κΈ°μ΅΄ νƒ€μ…μ—μ„ λ‹¤λ¥Έ νƒ€μ…μΌλ΅ κ°”λ‹¤ μ¬ λ• **κ°’μ΄ λ³€κ²½λμ§€ μ•λ” μΉ΄ν…κ³ λ¦¬**λ¥Ό `Identity`λΌκ³  ν•λ‹¤.<br/>

```typescript
Identity.of(1).chain(Identity.of); // Identity.of(1)
```

μ„ μ½”λ“μ `Identity<number>` νƒ€μ…μ€ `chain` λ©”μ„λ“λ¥Ό ν†µν•΄ λ‹¤μ‹ μμ‹ μ νƒ€μ…μΌλ΅ λμ•„μ¬ μ μλ‹¤.<br/>

### κ°’ μ»¨ν…μ΄λ„λ΅μ„μ Identity\<T> κµ¬ν„ν•κΈ°

μ•„λμ `Identity` ν΄λμ¤λ” κ°’ μ†μ„±μΈ `_value`λ¥Ό `private`ν•κ² κ°€μ§€κ³  μλ‹¤.<br/>
λ”°λΌμ„ `_value`λ¥Ό μ–»κΈ° μ„ν•΄ `public`ν• `value` λ©”μ„λ“λ¥Ό μ‚¬μ©ν•΄μ•Ό ν•λ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { IValuable } from "../interfaces";

export class Identity<T> implements IValuable<T> {
    constructor(private _value: T) {}
    value() {
        return this._value;
    }
}
```

`Identity<T>` ν΄λμ¤λ” `IValuable<T>` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•κ³  μλ” **κ°’ μ»¨ν…μ΄λ„ ν΄λμ¤λ‹¤**.<br/>

### ISetoid\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ `setoid`λ” `equals`λΌλ” μ΄λ¦„μ λ©”μ„λ“λ¥Ό μ κ³µν•λ” μΈν„°νμ΄μ¤λ¥Ό μλ―Έν•λ‹¤.<br/>

-   `interfaces/ISetoid.ts`

```typescript
import { IValuable } from "./IValuable";

export interface ISetoid<T> extends IValuable<T> {
    equals<U>(value: U): boolean;
}
```

Typescriptλ΅ `setoid` μΈν„°νμ΄μ¤λ” μ„μ™€ κ°™μ΄ κµ¬ν„ν•  μ μλ‹¤.<br/>
`ISetoid<T>`μ—λ” κ°’μ΄ μ—†κΈ° λ•λ¬Έμ— κ°’μ„ λΉ„κµν•κΈ° μ„ν•΄ `IValuable<T>` μΈν„°νμ΄μ¤λ¥Ό μƒμ†ν•λ‹¤.<br/>
`Identity<T>`μ— `ISetoid<T>` μΈν„°νμ΄μ¤λ¥Ό μ•„λμ™€ κ°™μ΄ κµ¬ν„ν•  μ μλ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid } from "../interfaces";

export class Identity<T> implements ISetoid<T> {
    constructor(private _value: T) {}
    value() {
        return this._value;
    }
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }
}
```

`ISetoid<T>` μΈν„°νμ΄μ¤λ¥Ό μƒμ†ν• ν›„ `equals` ν•¨μλ¥Ό μ„μ™€ κ°™μ΄ κµ¬ν„ν•μ€λ‹¤.<br/>
μ•„λμ ν…μ¤νΈ μ½”λ“λ¥Ό μ‚¬μ©ν•΄ κµ¬ν„λ `ISetoid<T>` ν΄λμ¤λ¥Ό ν…μ¤νΈν•  μ μλ‹¤.<br/>

-   `test/ISetoid-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const one = new Identity(1),
    anotherOne = new Identity(1);
const two = new Identity(2);

console.log(one.equals(anotherOne)); // true
console.log(one.equals(two)); // false
console.log(one.equals(1)); // false
console.log(one.equals(null)); // false
console.log(one.equals([1])); // false
```

λ³€μ `one`μ€ λ‘κ°™μ€ `Identity<number>` νƒ€μ… λ³€μμΈ `anotherOne`μ—λ§ `true`λ¥Ό λ°ν™ν•λ‹¤.<br/>
`equals` ν•¨μμ—μ„ λ§¤κ°λ³€μ `that`μ΄ `Identity`μ μΈμ¤ν„΄μ¤μ„μ„ νλ³„ν•κΈ° λ•λ¬Έμ΄λ‹¤.<br/>
λ§¤κ°λ³€μ `that`μ΄ `Identity` μΈμ¤ν„΄μ¤κ°€ μ•„λ‹λ©΄ λ¬΄μ΅°κ±΄ `false`λ¥Ό λ°ν™ν•κ² λλ‹¤.<br/>
λ§μ•½ `Identity`μ μΈμ¤ν„΄μ¤λΌλ©΄ `value` ν•¨μλ΅ κ°’μ„ κ°€μ Έμ™€ `==` μ—°μ‚°μλ΅ λΉ„κµν•κ² λλ‹¤.<br/>

### IFunctor\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ **ν‘ν„°**λ” `map`μ΄λΌλ” λ©”μ„λ“λ¥Ό μ κ³µν•λ” μΈν„°νμ΄μ¤λ‹¤.<br/>

-   `interfaces/IFunctor.ts`

```typescript
export interface IFunctor<T> {
    map<U>(fn: (x: T) => U);
}
```

**μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ—μ„ **ν‘ν„°**λ” **μ—”λ„ ν‘ν„°**λΌλ” νΉλ³„ν• μ„±μ§μ„ λ§μ΅±ν•΄μ•Ό ν•λ‹¤.<br/>
Typescript 3.7.4 λ²„μ „μ—μ„λ” **μ—”λ„ν‘ν„°**λ¥Ό κµ¬ν„ν•  μ μκ² ν•λ” κµ¬λ¬Έμ„ μ κ³µν•μ§€ μ•λ”λ‹¤.<br/>
λ”°λΌμ„ `IFunctor`μ `map` λ©”μ„λ“μ λ°ν™ νƒ€μ…μ„ μƒλµν• μ΄μ λ” **μ—”λ„ ν‘ν„°**λ¥Ό κµ¬ν„ν•κΈ° μ„ν•΄μ„λ‹¤.<br/>

### μ—”λ„ν‘ν„°λ€?

**μ—”λ„**λ” λ‹¨μ–΄ μ•μ— λ¶™λ” μΌμΆ…μ μ ‘λ‘μ‚¬λ‹¤.<br/>
**μ—”λ„ν‘ν„°**λ” νΉμ • μΉ΄ν…κ³ λ¦¬μ—μ„ μ¶λ°ν•΄ **λ‹¤μ‹ μ¶λ° μΉ΄ν…κ³ λ¦¬λ΅ λ„μ°©**ν•λ” **ν‘ν„°**λ¥Ό μλ―Έν•λ‹¤.<br/>
μ•„λμ `Identity<T>`μ `map` λ©”μ„λ“μ κµ¬ν„ λ‚΄μ©μ€ **μ—”λ„ν‘ν„°**λ΅ λ™μ‘ν•κ² ν•λ” μ½”λ“λ‹¤.<br/>

-   `classes/Identtiy.ts`

```typescript
import { ISetoid, IFunctor } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IFunctor<T> {
    constructor(private _value: T) {}

    // IValualbe
    value() {
        return this._value;
    }

    // ISetoid
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }

    // IFunctor
    map<U>(fn: (x: T) => U) {
        return new Identity<U>(fn(this.value()));
    }
}
```

κ°’ νƒ€μ… `T`κ°€ `U`λ΅ λ°”λ€” μλ” μμ§€λ§ **μΉ΄ν…κ³ λ¦¬**λ” μ—¬μ „ν `Identity`μ— λ¨Έλ¬Όκ² ν•λ‹¤.<br/>

### IApply\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ **μ–΄ν”λΌμ΄**λ” **ν‘ν„°**μ΄λ©΄μ„ `ap` λ©”μ„λ“λ¥Ό μ κ³µν•λ” μΈν„°νμ΄μ¤λ‹¤.<br/>

-   `interfaces/IApply.ts`

```typescript
import { IFunctor } from "./IFunctor";

export interface IApply<T> extends IFunctor<T> {
    ap<U>(b: U);
}
```

`IApply<T>`λ¥Ό κµ¬ν„ν•λ” **μ»¨ν…μ΄λ„**λ” **κ°’ μ»¨ν…μ΄λ„**μ΄λ©° **κ³ μ°¨ ν•¨μμ μ»¨ν…μ΄λ„**λ΅λ„ λ™μ‘ν•λ‹¤.<br/>
μ•„λμ™€ κ°™μ€ ν…μ¤νΈ μ½”λ“λ΅ `IApply`μ λ™μ‘μ„ μ΄ν•΄ν•  μ μλ‹¤.<br/>

-   `test/IApply-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const add = (x) => (y) => x + y;
const id = new Identity(add);

console.log(id.ap(1).ap(2).value()); // 3
```

`Identity`λ” `add`λΌλ” **2μ°¨ κ³ μ°¨ ν•¨μ**λ¥Ό κ°’μΌλ΅ κ°€μ§€κ³  μλ‹¤.<br/>
`add`λ” **2μ°¨ κ³ μ°¨ ν•¨μ**μ΄λ―€λ΅ `ap` λ©”μ„λ“λ¥Ό λ‘ λ² νΈμ¶ν•΄ ν•¨μλ¥Ό λ™μ‘μ‹ν‚¨λ‹¤.<br/>

```typescript
import { ISetoid, IApply } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApply<T> {
    // ... μƒλµ ...
    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Identity.of<U>((f as Function)(b));
        }
    }
}
```

`IApply<T>` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” `Identity` ν΄λμ¤μ `ap` λ©”μ„λ“λ” μ„μ™€ κ°™λ‹¤.<br/>

### IApplicative\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ **μ• ν”λ¦¬μ»¤ν‹°λΈ**λ” `Apply`λ©΄μ„ `of`λΌλ” ν΄λμ¤ λ©”μ„λ“λ¥Ό μ κ³µν•λ” μΈν„°νμ΄μ¤λ‹¤.<br/>

-   `interfaces/IApplicative.ts`

```typescript
import { IApply } from "./IApply";

export interface IApplicative<T> extends IApply<T> {
    // static of(value: T);
}
```

Typescript 3.7.4λ²„μ „μ—μ„λ” `interface`μ— μ •μ  λ©”μ„λ“λ¥Ό κµ¬ν„ν•μ§€ λ»ν•λ‹¤.<br/>
λ”°λΌμ„ μ„μ™€ κ°™μ΄ μ£Όμ„ μ²λ¦¬λ¥Ό ν• ν›„ `Identity` ν΄λμ¤μ— `of` λ©”μ„λ“λ¥Ό κµ¬ν„ν•΄μ•Ό ν•λ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IApplicative } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApplicative<T> {
    // ... μƒλµ ...
    static of<T>(value: T): Identity<T> {
        return new Identity<T>(value);
    }
}
```

λν• 3.7.4 λ²„μ „μ Typescriptλ” μ •μ  λ©”μ„λ“μ λ°ν™ νƒ€μ…μ— `this`λ¥Ό μ‚¬μ©ν•  μ μ—†λ‹¤.<br/>
λ”°λΌμ„ `IApply`μ `of` λ©”μ„λ“μ λ°ν™ νƒ€μ…μ„ μƒλµν•΄ κµ¬ν„ν•μ€λ‹¤.<br/>

### IChian\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ **μ²΄μΈ**μ€ `Apply`λ©΄μ„ `chain`μ΄λΌλ” λ©”μ„λ“λ¥Ό κµ¬ν„ν•λ” μΈν„°νμ΄μ¤λ‹¤.<br/>

-   `interfaces/chain.ts`

```typescript
import { IApply } from "./IApply";

export interface IChain<T> extends IApply<T> {
    chain<U>(fn: (T) => U);
}
```

**λ¨λ‚λ“** νΉμ„±μ— λ”°λΌ `chain`μ€ `U` νƒ€μ…μ„ λ°ν™ν•μ§€ μ•μ„ μ μμ–΄ λ°ν™ νƒ€μ…μ„ μ§€μ •ν•μ§€ μ•μ•λ‹¤.<br/>
**μ²΄μΈ**μ `chain` λ©”μ„λ“λ” **ν‘ν„°**μ `map`κ³Ό λ‹¬λ¦¬ **μ—”λ„ν‘ν„°**λ΅ κµ¬ν„ν•΄μ•Όν•  μλ―Έκ°€ μ—†λ‹¤.<br/>
λ”°λΌμ„ μ•„λ μ½”λ“μ `chain`μ€ `map`κ³Ό ν•¨μ μ‹κ·Έλ‹μ²λ” κ°™μ§€λ§ κµ¬ν„ λ‚΄μ©μ€ μ΅°κΈ λ‹¤λ¥΄λ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IApplicative, IChain } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApplicative<T>, IChain<T> {
    // ... μƒλµ...
    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

**μ—”λ„ ν‘ν„°**μΈ `map`μ€ ν•μƒ κ°™μ€ μΉ΄ν…κ³ λ¦¬μ— λ¨Έλ¬΄λ¥Έλ‹¤.<br/>
λ°λ©΄μ— `chain`μ€ μμ‹ μ΄ λ¨Έλ¬΄λ¥΄κ³  μ‹¶μ€ μΉ΄ν…κ³ λ¦¬λ¥Ό μ¤μ¤λ΅ μ •ν•΄μ•Ό ν•λ‹¤.<br/>

-   `test/IMap-IChain-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

console.log(
    Identity.of(1)
        .map((value) => `the count is ${value}`)
        .value()
); // the count is 1
console.log(
    Identity.of(1).chain((value) =>
        Identity.of(`the count is ${value}`).value()
    )
); // the count is 1
```

μ„μ `map`κ³Ό `chain`μ„ μ‚¬μ©ν•λ” μ½”λ“λ” κ°™μ€ κ²°κ³Όλ¥Ό λ³΄μ΄μ§€λ§ μ‚¬μ©λ²•μ— μ°¨μ΄κ°€ μλ‹¤.<br/>

### IMonad\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ **λ¨λ‚λ“**λ” μ•„λμ²λΌ **μ²΄μΈ**κ³Ό **μ• ν”λ¦¬μ»¤ν‹°λΈ**λ¥Ό κµ¬ν„ν• κ²ƒμ΄λ‹¤.<br/>

-   `interfaces/IMonad.ts`

```typescript
import { IChain } from "./IChain";
import { IApplicative } from "./IApplicative";

export interface IMonad<T> extends IChain<T>, IApplicative<T> {}
```

μ΄μ  μ•„λμ™€ κ°™μ€ `Identity<T>` λ¨λ‚λ“κ°€ μ™„μ„± λμ—λ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IMonad } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IMonad<T> {
    constructor(private _value: T) {}

    // IValualbe
    value() {
        return this._value;
    }

    // ISetoid
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }

    // IFunctor
    map<U>(fn: (x: T) => U) {
        return new Identity<U>(fn(this.value()));
    }

    // IApply
    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Identity.of<U>((f as Function)(b));
        }
    }

    // IApplicative
    static of<T>(value: T): Identity<T> {
        return new Identity<T>(value);
    }

    // IChain
    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

μ•„λ μ½”λ“λ” μ™„μ„±λ `Identity<T>` λ¨λ‚λ“κ°€ **μ™Όμ½ λ²•μΉ™**μ„ λ§μ΅±ν•λ”μ§€ ν…μ¤νΈν•λ” μ½”λ“λ‹¤.<br/>

-   `test/IMonad-Left-Law-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const a = 1;
const f = (a) => a * 2;

console.log(Identity.of(a).chain(f) == f(a)); // true
```

μ„μ μ½”λ“λ¥Ό μ‹¤ν–‰ν•λ©΄ `true`κ°€ μ¶λ ¥λ¨μ— λ”°λΌ `Identity<T>`κ°€ **λ¨λ‚λ“ μ™Όμ½ λ²•μΉ™**μ„ λ§μ΅±ν•λ‹¤.<br/>
μ•„λ μ½”λ“λ” `Identity<T>`κ°€ **μ¤λ¥Έμ½ λ²•μΉ™**μ„ λ§μ΅±ν•λ”μ§€ ν…μ¤νΈν•λ” λ‚΄μ©μ΄λ‹¤.<br/>

-   `test/IMonad-Right-Law-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const m = Identity.of(1);

console.log(m.chain(Identity.of).equals(m)); // true
```

μ„μ μ½”λ“μ κ²°κ³Ό μ—­μ‹ `true`κ°€ μ¶λ ¥λλ―€λ΅ `Identity<T>`κ°€ **μ¤λ¥Έμ½ λ²•μΉ™**μ„ λ§μ΅±ν•λ‹¤.<br/>
λ”°λΌμ„ `Identity<T>`λ” **μ¤λ¥Έμ½ λ²•μΉ™**κ³Ό **μ™Όμ½ λ²•μΉ™** λ¨λ‘ λ§μ΅±ν•λ―€λ΅ μ •μƒμ μΈ **λ¨λ‚λ“**λ‹¤.<br/>
μ•„λ μ½”λ“λ” `Identity` νƒ€μ… κ°μ²΄μ λ©”μ„λ“λ“¤μ„ λ©”μ„λ“ μ²΄μΈ ν•νƒλ΅ νΈμ¶ν•λ‹¤.<br/>

-   `test/IMonad-Method-Chain-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

type IPerson = { name: string; age: number };
const jack = Identity.of(["Jack", 32]);

console.log(
    jack
        .map(([name, age]) => ({ name, age }))
        .chain((p: IPerson) => Identity.of(p))
        .map(({ name, age }) => [name, age])
        .value()[0] == jack.value()[0]
); // true
```

**λ¨λ‚λ“**λ” μ„μ™€ κ°™μ΄ **μ„ μ–Έν• ν”„λ΅κ·Έλλ°**μ„ μ—Όλ‘μ— λ‘κ³  μ„¤κ³„λμ—λ‹¤.<br/>

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-3 Maybe λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-4 Validation λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-5 IO λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
