# 11μ¥ λ¨λ‚λ“

<details><summary>Table of Contents</summary>

-   11-1 λ¨λ‚λ“ μ΄ν•΄ν•κΈ° [:link:](#11-1-λ¨λ‚λ“-μ΄ν•΄ν•κΈ°)
    -   νƒ€μ… ν΄λμ¤λ€? [:link:](#νƒ€μ…-ν΄λμ¤λ€)
    -   κ³ μ°¨ νƒ€μ…μ΄λ€? [:link:](#κ³ μ°¨-νƒ€μ…μ΄λ€)
    -   μΉ΄ν…κ³ λ¦¬ μ΄λ΅ μ΄λ€? [:link:](#μΉ΄ν…κ³ λ¦¬-μ΄λ΅ μ΄λ€)
    -   ννƒ€μ§€λλ“ κ·κ²© [:link:](#ννƒ€μ§€λλ“-κ·κ²©)
    -   λ¨λ‚λ“ λ£° [:link:](#λ¨λ‚λ“-λ£°)
-   11-2 Identity λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„ [:link:](#11-2-identity-λ¨λ‚λ“-μ΄ν•΄μ™€-κµ¬ν„)
    -   ν”„λ΅μ νΈ κµ¬μ„± [:link:](#ν”„λ΅μ νΈ-κµ¬μ„±)
    -   κ°’ μ»¨ν…μ΄λ„ κµ¬ν„μ© IValuable\<T> μΈν„°νμ΄μ¤ κµ¬ν„ [:link:](#κ°’-μ»¨ν…μ΄λ„-κµ¬ν„μ©-ivaluablet-μΈν„°νμ΄μ¤-κµ¬ν„)
    -   ν΄λμ¤ μ΄λ¦„μ΄ μ™ Identity μΈκ°€? [:link:](#ν΄λμ¤-μ΄λ¦„μ΄-μ™-identity-μΈκ°€)
    -   κ°’ μ»¨ν…μ΄λ„λ΅μ„μ Identity\<T> κµ¬ν„ν•κΈ° [:link:](#κ°’-μ»¨ν…μ΄λ„λ΅μ„μ-identityt-κµ¬ν„ν•κΈ°)
    -   ISetoid\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#isetoidt-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   IFunctor\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#ifunctort-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   μ—”λ„ν‘ν„°λ€? [:link:](#μ—”λ„ν‘ν„°λ€)
    -   IApply\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#iapplyt-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   IApplicative\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#iapplicativet-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   IChian\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#ichiant-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
    -   IMonad\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„ [:link:](#imonadt-μΈν„°νμ΄μ¤μ™€-κµ¬ν„)
-   11-3 Maybe λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„ [:link:](#11-3-maybe-λ¨λ‚λ“-μ΄ν•΄μ™€-κµ¬ν„)
    -   ν”„λ΅μ νΈ κµ¬μ„± [:link:](#2)
    -   Maybe λ¨λ‚λ“λ€? [:link:](#maybe-λ¨λ‚λ“λ€)
    -   Maybe ν΄λμ¤ κµ¬μ΅° [:link:](#maybe-ν΄λμ¤-κµ¬μ΅°)
    -   Maybeκ°€ ν•¨μμ λ°ν™ νƒ€μ…μΌ λ•μ λ¬Έμ μ  [:link:](#maybeκ°€-ν•¨μμ-λ°ν™-νƒ€μ…μΌ-λ•μ-λ¬Έμ μ )
    -   Just λ¨λ‚λ“ κµ¬ν„ [:link:](#just-λ¨λ‚λ“-κµ¬ν„)
    -   Nothing λ¨λ‚λ“ κµ¬ν„ [:link:](#nothing-λ¨λ‚λ“-κµ¬ν„)
    -   Justμ™€ Nothing λ¨λ‚λ“ λ‹¨μ„ ν…μ¤νΈ [:link:](#justμ™€-nothing-λ¨λ‚λ“-λ‹¨μ„-ν…μ¤νΈ)
    -   Maybe ν…μ¤νΈ [:link:](#maybe-ν…μ¤νΈ)
-   11-4 Validation λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„ [:link:](#11-4-validation-λ¨λ‚λ“-μ΄ν•΄μ™€-κµ¬ν„)
-   11-5 IO λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„ [:link:](#11-5-io-λ¨λ‚λ“-μ΄ν•΄μ™€-κµ¬ν„)

</details>

## 11-1 λ¨λ‚λ“ μ΄ν•΄ν•κΈ°

### νƒ€μ… ν΄λμ¤λ€?

**νƒ€μ… ν΄λμ¤**μ ν•„μ”μ„±μ„ μ΄ν•΄ν•λ” κ²ƒμ€ **λ¨λ‚λ“**λ¥Ό μ΄ν•΄ν•κΈ° μ„ν•΄ μ¤‘μ”ν•λ‹¤.<br/>
μ•„λμ 2μ°¨ κ³ μ°¨ ν•¨μ `callMap`μ€ κ³ μ°¨ λ§¤κ°λ³€μ `b`κ°€ `map` λ©”μ„λ“λ¥Ό κ°€μ΅λ‹¤λ” κ°€μ •μΌλ΅ κµ¬ν„λμ—λ‹¤.<br/>

```typescript
const callMap = (fn) => (b) => b.map(fn);
```

λ”°λΌμ„ μ•„λμ™€ κ°™μ€ μ½”λ“λ¥Ό μ‚¬μ©ν•λ©΄ μ •μƒμ μΌλ΅ μ‘λ™ν•λ‹¤.<br/>

```typescript
callMap((a) => a + 1)([1]);
```

ν•μ§€λ§ μ•„λμ™€ κ°™μ΄ μ‘μ„±μ‹ ν”„λ΅κ·Έλ¨μ΄ λΉ„μ •μƒμ μΌλ΅ μΆ…λ£λλ‹¤.<br/>

```typescript
callMap((a) => a + 1)(1);
```

μ΄λ¥Ό λ°©μ§€ν•λ ¤λ©΄ μ•„λμ²λΌ λ§¤κ°λ³€μ `b`λ” λ°λ“μ‹ `map` λ©”μ„λ“κ°€ μλ” νƒ€μ…μΌλ΅ μ ν•ν•΄μ•Ό ν•λ‹¤.<br/>

```typescript
const callMap = <T, U>(fn: (T) => U) => <T extends { map(fn) }>(b: T) =>
    b.map(fn);
```

μ•„λμ™€ κ°™μ΄ `map` λ©”μ„λ“κ°€ μ—†λ” `1`μ€ κ³ μ°¨ λ§¤κ°λ³€μλ΅ μ‚¬μ©ν•  μ μ—†λ‹¤.<br/>

<img src="./images/1.png" width="500" height="auto">

λ”°λΌμ„ μ½”λ“λ¥Ό μ‘μ„±ν•λ” μ‹μ μ— ν”„λ΅κ·Έλ¨μ΄ λΉ„μ •μƒμ μΌλ΅ μ •λ£λλ” κ²ƒμ„ λ§‰μ„ μ μλ‹¤.<br/>
λ³΄ν†µ κ°μ²΄μ§€ν–¥ μ–Έμ–΄λΌλ©΄ `map` λ©”μ„λ“λ¥Ό κ°–λ” `Number` ν΄λμ¤λ¥Ό κµ¬ν„ν•λ” μ‹μΌλ΅ μ„¤κ³„ν•  κ²ƒμ΄λ‹¤.<br/>
ν•μ§€λ§ **λ¨λ‚λ“** λ°©μ‹ μ„¤κ³„λ” λ°λ“μ‹ `map`κ³Ό `of`λΌλ” λ©”μ„λ“κ°€ μλ” `Monad<T>` ν΄λμ¤λ¥Ό λ§λ“ λ‹¤.<br/>

```typescript
class Monad<T> {
    constructor(public value: T) {}
    static of<U>(value: U): Monad<U> {
        return new Monad<U>(value);
    }
    map<U>(fn: (x: T) => U): Monad<U> {
        return new Monad<U>(fn(this.value));
    }
}
```

μ΄μ²λΌ `Monad<T>`μ™€ κ°™μ€ ν΄λμ¤λ¥Ό **νƒ€μ… ν΄λμ¤**λΌκ³  ν•λ‹¤.<br/>
**νƒ€μ… ν΄λμ¤**λ” λ‹¤μμ²λΌ ν•¨μλ¥Ό λ§λ“¤ λ• νΉλ³„ν• νƒ€μ…μΌλ΅ μ μ•½ν•μ§€ μ•μ•„λ„ λλ‹¤.<br/>

```typescript
const callMonad = (fn) => (b) => Monad.of(b).map(fn).value;
```

**νƒ€μ… ν΄λμ¤** λ•λ¶„μ— **νƒ€μ…μ— λ”°λ¥Έ μ•μ •μ„±μ„ λ³΄μ¥**ν•κ³  μ½”λ“μ **μ¬μ‚¬μ©μ„±μ΄ λ›°μ–΄λ‚ λ²”μ© ν•¨μ**λ¥Ό μ‰½κ² λ§λ“¤ μ μλ‹¤.<br/>

```typescript
callMonad((a: number) => a + 1)(1); // 2
callMonad((a: number[]) => a.map((value) => value + 1))([1, 2, 3, 4]); // [ 2, 3, 4, 5 ]
```

`callMonad`μ™€ κ°™μ€ ν•¨μλ” ν• λ²λ§ λ§λ“¤λ©΄ μ„μ²λΌ **λ§¤κ°λ³€μμ νƒ€μ…μ— λ¬΄κ΄€**ν• κ°„κ²°ν• μ½”λ“λ¥Ό μ‘μ„±ν•  μ μλ‹¤.<br/>

### κ³ μ°¨ νƒ€μ…μ΄λ€?

`Monad<T>`λ” νƒ€μ… `T`λ¥Ό `Monad<T>`λ΅ λ³€ν™ν–λ‹¤ λ‹¤μ‹ νƒ€μ… `T`λ΅ λ³€ν™ν•΄μ¤€λ‹¤.<br/>
`Monad<T>`μ™€ κ°™μ΄ νƒ€μ… `T`λ¥Ό ν• λ‹¨κ³„ λ” λ†’μ€ νƒ€μ…μΌλ΅ λ³€ν™ν•λ” μ©λ„μ νƒ€μ…μ„ **κ³ μ°¨ νƒ€μ…**μ΄λΌ ν•λ‹¤.<br/>
**κ³ μ°¨ νƒ€μ…**μ€ **μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ΄λΌλ” μν•™μ—μ„ μ•„μ΄λ””μ–΄λ¥Ό μ–»μ—λ‹¤.<br/>
Typescriptμ—μ„λ” `Monad<T>`μ™€ κ°™μ΄ **2μ°¨ κ³ μ°¨ νƒ€μ…**μ„ λ§λ“¤ μ μκ² ν•λ” κµ¬λ¬Έμ„ μ κ³µν•λ‹¤.<br/>
ν•μ§€λ§ μ¤μΉΌλΌ μ–Έμ–΄μ²λΌ `Functor[F[_]]` κ°™μ€ 3μ°¨ μ΄μƒμ κ³ μ°¨ νƒ€μ…μ€ λ§λ“¤ μ μ—†λ‹¤.<br/>

### μΉ΄ν…κ³ λ¦¬ μ΄λ΅ μ΄λ€?

**μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ€ 1940λ…„μ— μ‹μ‘λ μν•™μ ν• λ¶„μ•Όλ΅ ν•¨μν• ν”„λ΅κ·Έλλ° μ–Έμ–΄μ μ¤‘μ”ν• μ΄λ΅ μ μΈ λ°°κ²½μ΄ λμ—λ‹¤.<br/>
**μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ€ ν”ν μ•„λμ κ·Έλ¦ΌμΌλ΅ ν‘ν„λλ‹¤.<br/>

<img src="./images/2.png" width="500" height="auto">

μν•™μ—μ„ **μ§‘ν•©**μ€ ν”„λ΅κ·Έλλ°μ—μ„μ **νƒ€μ…**μ΄λ‹¤.<br/>
μν•™μ—μ„ **μΉ΄ν…κ³ λ¦¬**λ” **μ§‘ν•©μ μ§‘ν•©**μΌλ΅ μ΄ν•΄ν•  μ μλ‹¤.<br/>
λ”°λΌμ„ ν”„λ΅κ·Έλλ°μ—μ„μ **μΉ΄ν…κ³ λ¦¬**λ” **νƒ€μ…μ νƒ€μ…**μΌλ΅ **κ³ μ°¨ νƒ€μ…**μΌλ΅ μ΄ν•΄ν•  μ μλ‹¤.<br/>
λν• **λ¨λ‚λ“**λ” λ³„λ„μ νΉμ§•μ΄ μλ” **κ³ μ°¨ νƒ€μ…**μ΄λ‹¤.<br/>

### ννƒ€μ§€λλ“ κ·κ²©

**λ¨λ‚λ“**λ” ν•μ¤μΌ μ–Έμ–΄μ `Prelude`λΌλ” ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬μ—μ„ μ‚¬μ©λλ” μ©μ–΄μ΄κΈ°λ„ ν•λ‹¤.<br/>
**λ¨λ‚λ“**λ” **λ¨λ‚λ“ λ£°**μ΄λΌκ³  ν•λ” μ½”λ“ μ„¤κ³„ μ›μΉ™μ— λ§μ¶° κµ¬ν„λ ν΄λμ¤λ¥Ό μλ―Έν•λ‹¤.<br/>
μ•„λ κ·Έλ¦Όμ€ Githubμ— μλ” [ννƒ€μ§€λλ“ κ·κ²©](https://github.com/fantasyland/fantasy-land)μ— μλ” κ·Έλ¦Ό μ¤‘ λ¶€λ¶„μ΄λ‹¤.<br/>

<img src="./images/3.png" width="550" height="auto">

ννƒ€μ§€λλ“ κ·κ²©μ€ ν•μ¤μΌ ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬ κµ¬μ΅°λ¥Ό Javascript λ°©μ‹μΌλ΅ μ¬κµ¬μ„±ν• κ²ƒμ΄λ‹¤.<br/>
κ·Έλ¦Όμ—μ„ λ³΄λ©΄ **λ¨λ‚λ“**λ” μ•„λ λ„¤ κ°€μ§€ μ”μ†λ¥Ό κµ¬ν„ν• κ²ƒμ„μ„ μ• μ μλ‹¤.<br/>

-   **ν‘ν„°**(**Functor**) : `map`μ΄λΌλ” μΈμ¤ν„΄μ¤ λ©”μ„λ“λ¥Ό κ°€μ§€λ” ν΄λμ¤
-   **μ–΄ν”λΌμ΄**(**Apply**) : **ν‘ν„°**μ΄λ©΄μ„ `ap`λΌλ” μΈμ¤ν„΄μ¤ λ©”μ„λ“λ¥Ό κ°€μ§€λ” ν΄λμ¤
-   **μ• ν”λ¦¬μ»¤ν‹°λΈ**(**Applicative**) : **μ–΄ν”λΌμ΄**μ΄λ©΄μ„ `of`λΌλ” ν΄λμ¤ λ©”μ„λ“λ¥Ό κ°€μ§€λ” ν΄λμ¤
-   **μ²΄μΈ**(**Chain**) : **μ• ν”λ¦¬μ»¤ν‹°λΈ**μ΄λ©΄μ„ `chain`μ΄λΌλ” λ©”μ„λ“λ¥Ό κ°€μ§€λ” ν΄λμ¤

μ–΄λ–¤ ν΄λμ¤κ°€ μ„μ λ„¤ κ°€μ§€ μ΅°κ±΄μ„ λ¨λ‘ λ§μ΅±ν•λ‹¤λ©΄ κ·Έ ν΄λμ¤λ” **λ¨λ‚λ“**λ‹¤.<br/>

### λ¨λ‚λ“ λ£°

ν΄λμ¤ μ΄λ¦„μ΄ `M`μ΄κ³  μΈμ¤ν„΄μ¤λ¥Ό `m`μ΄λΌκ³  ν• λ• **λ¨λ‚λ“**λ” **μ• ν”λ¦¬μ»¤ν‹°λΈ**μ™€ **μ²΄μΈ**μ κΈ°λ¥μ„ κ°–λ”λ‹¤.<br/>
λν• ν•΄λ‹Ή **λ¨λ‚λ“** ν΄λμ¤λ” μ•„λμ™€ κ°™μ€ λ‘ κ°€μ§€ λ²•μΉ™μ„ λ§μ΅±ν•λ‹¤.<br/>

|             κµ¬λ¶„             |            μλ―Έ            |
| :--------------------------: | :------------------------: |
|  μ™Όμ½ λ²•μΉ™ (Left Identity)   | `M.of(a).chain(f) == f(a)` |
| μ¤λ¥Έμ½ λ²•μΉ™ (Right Identity) |    `m.chain(M.of) == m`    |

ν•μ¤μΌμ `Prelude` ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬λ” `Maybe`μ™€ κ°™μ€ λ―Έλ¦¬ κµ¬ν„λ **λ¨λ‚λ“**λ¥Ό μ κ³µν•λ‹¤.<br/>
Typescriptλ” **λ¨λ‚λ“** λΌμ΄λΈλ¬λ¦¬λ¥Ό μ κ³µν•μ§€ μ•μΌλ―€λ΅ **ννƒ€μ§€λλ“ κ·κ²©**μ— λ§μ¶° μ‘μ„±ν•΄μ•Ό ν•λ‹¤.<br/>

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-2 Identity λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„

### ν”„λ΅μ νΈ κµ¬μ„±

μ•„λμ™€ κ°™μ΄ Typescriptλ¥Ό μ‚¬μ©ν•λ” node.js ν”„λ΅μ νΈλ¥Ό κµ¬μ„±ν•λ‹¤.<br/>

```shell
> npm init --y
> npm i -D typescript ts-node @types/node
> mkdir -p src/test
> mkdir src/interfaces
> mkdir src/classes
```

`tsconfig.json` νμΌμ€ μ•„λμ™€ κ°™μ΄ μ„¤μ •ν•λ‹¤.<br/>

```typescript
{
    "compilerOptions": {
        "module": "CommonJS",
        "esModuleInterop": true,
        "target": "es5",
        "moduleResolution": "node",
        "outDir": "dist",
        "baseUrl": ".",
        "sourceMap": true,
        "downlevelIteration": true,
        "noImplicitAny": false,
        "paths": {
            "*": ["node_modules/*"]
        }
    },
    "include": ["src/**/*"]
}
```

κΈ°μ΅΄μ— μ‚¬μ©ν–λ `tsconfig.json` νμΌ μ„¤μ •λ“¤κ³Ό λ™μΌν•κ² μ„¤μ •ν•μ€λ‹¤.<br/>

### κ°’ μ»¨ν…μ΄λ„ κµ¬ν„μ© IValuable\<T> μΈν„°νμ΄μ¤ κµ¬ν„

μ–΄λ–¤ νƒ€μ… `T`κ°€ μμ„ λ• λ°°μ—΄ `T[]`λ” κ°™μ€ νƒ€μ…μ μ•„μ΄ν…μ„ μ—¬λ¬ κ° κ°€μ§„ **μ»¨ν…μ΄λ„**λ‹¤.<br/>
λ³΄ν†µ **μ»¨ν…μ΄λ„**λΌλ” μ©μ–΄λ” μ΄μ²λΌ ν”ν **λ°°μ—΄**μ„ μλ―Έν•λ‹¤.<br/>
ν•μ§€λ§ `Monad<T>`μ²λΌ **λ°°μ—΄μ΄ μ•„λ‹ ν• κ°μ κ°’μ„ κ°€μ§€λ” μ»¨ν…μ΄λ„ ν΄λμ¤**λ¥Ό μƒκ°ν•  μ μλ‹¤.<br/>
μ΄ **μ»¨ν…μ΄λ„ ν΄λμ¤**λ” λ¨λ“  νƒ€μ… `T`μ κ°’μ„ κ°€μ§ μ μλ” **μ λ„¤λ¦­ μ»¨ν…μ΄λ„ ν΄λμ¤**λ‹¤.<br/>
μ΄μ²λΌ νƒ€μ… `T`λ¥Ό κ°€μ§€λ” κ°’μ μ»¨ν…μ΄λ„λ¥Ό **κ°’ μ»¨ν…μ΄λ„**λΌκ³  ν•λ‹¤.<br/>
**κ°’ μ»¨ν…μ΄λ„**λ¥Ό κµ¬ν„ν•κΈ° μ„ν•΄ μ•„λμ `IValuable<T>` μΈν„°νμ΄μ¤λ¥Ό μ‘μ„±ν•λ‹¤.<br/>

-   `interfaces/IValuable.ts`

```typescript
export interface IValuable<T> {
    value(): T;
}
```

λν• μ•μΌλ΅ `Identity<T>`μ μ½”λ“λ¥Ό νΈν•κ² μ‚¬μ©ν•κ³ μ μ•„λμ λ‚΄μ©μ `index.ts`λ¥Ό μ‘μ„±ν•λ‹¤.<br/>

-   `interfaces/index.ts`

```typescript
import { IValuable } from "./IValuable";
import { ISetoid } from "./ISetoid";
import { IFunctor } from "./IFunctor";
import { IApplicative } from "./IApplicative";
import { IApply } from "./IApply";
import { IChain } from "./IChain";
import { IMonad } from "./IMonad";

export { IValuable, ISetoid, IFunctor, IApplicative, IApply, IChain, IMonad };
```

### ν΄λμ¤ μ΄λ¦„μ΄ μ™ Identity μΈκ°€?

**ν•¨μν• ν”„λ΅κ·Έλλ°**μ—μ„ `identity`λ” ν•­μƒ μ•„λμ²λΌ κµ¬ν„ν•λ” νΉλ³„ν• μλ―Έμ ν•¨μλ‹¤.<br/>

```typescript
const identity = <T>(value: T): T => value;
```

μ•μ—μ„ λ³Έ `ramda` λΌμ΄λΈλ¬λ¦¬μ `R.identity` ν•¨μκ°€ `identity`λ¥Ό κµ¬ν„ν•κ³  μλ‹¤.<br/>
`Identity`λ” `map`, `ap`, `of`, `chain`κ³Ό κ°™μ€ κΈ°λ³Έ λ©”μ„λ“λ§ κµ¬ν„ν• **λ¨λ‚λ“**λ‹¤.<br/>
**μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ—μ„ κΈ°μ΅΄ νƒ€μ…μ—μ„ λ‹¤λ¥Έ νƒ€μ…μΌλ΅ κ°”λ‹¤ μ¬ λ• **κ°’μ΄ λ³€κ²½λμ§€ μ•λ” μΉ΄ν…κ³ λ¦¬**λ¥Ό `Identity`λΌκ³  ν•λ‹¤.<br/>

```typescript
Identity.of(1).chain(Identity.of); // Identity.of(1)
```

μ„ μ½”λ“μ `Identity<number>` νƒ€μ…μ€ `chain` λ©”μ„λ“λ¥Ό ν†µν•΄ λ‹¤μ‹ μμ‹ μ νƒ€μ…μΌλ΅ λμ•„μ¬ μ μλ‹¤.<br/>

### κ°’ μ»¨ν…μ΄λ„λ΅μ„μ Identity\<T> κµ¬ν„ν•κΈ°

μ•„λμ `Identity` ν΄λμ¤λ” κ°’ μ†μ„±μΈ `_value`λ¥Ό `private`ν•κ² κ°€μ§€κ³  μλ‹¤.<br/>
λ”°λΌμ„ `_value`λ¥Ό μ–»κΈ° μ„ν•΄ `public`ν• `value` λ©”μ„λ“λ¥Ό μ‚¬μ©ν•΄μ•Ό ν•λ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { IValuable } from "../interfaces";

export class Identity<T> implements IValuable<T> {
    constructor(private _value: T) {}
    value() {
        return this._value;
    }
}
```

`Identity<T>` ν΄λμ¤λ” `IValuable<T>` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•κ³  μλ” **κ°’ μ»¨ν…μ΄λ„ ν΄λμ¤λ‹¤**.<br/>

### ISetoid\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ `setoid`λ” `equals`λΌλ” μ΄λ¦„μ λ©”μ„λ“λ¥Ό μ κ³µν•λ” μΈν„°νμ΄μ¤λ¥Ό μλ―Έν•λ‹¤.<br/>

-   `interfaces/ISetoid.ts`

```typescript
import { IValuable } from "./IValuable";

export interface ISetoid<T> extends IValuable<T> {
    equals<U>(value: U): boolean;
}
```

Typescriptλ΅ `setoid` μΈν„°νμ΄μ¤λ” μ„μ™€ κ°™μ΄ κµ¬ν„ν•  μ μλ‹¤.<br/>
`ISetoid<T>`μ—λ” κ°’μ΄ μ—†κΈ° λ•λ¬Έμ— κ°’μ„ λΉ„κµν•κΈ° μ„ν•΄ `IValuable<T>` μΈν„°νμ΄μ¤λ¥Ό μƒμ†ν•λ‹¤.<br/>
`Identity<T>`μ— `ISetoid<T>` μΈν„°νμ΄μ¤λ¥Ό μ•„λμ™€ κ°™μ΄ κµ¬ν„ν•  μ μλ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid } from "../interfaces";

export class Identity<T> implements ISetoid<T> {
    constructor(private _value: T) {}
    value() {
        return this._value;
    }
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }
}
```

`ISetoid<T>` μΈν„°νμ΄μ¤λ¥Ό μƒμ†ν• ν›„ `equals` ν•¨μλ¥Ό μ„μ™€ κ°™μ΄ κµ¬ν„ν•μ€λ‹¤.<br/>
μ•„λμ ν…μ¤νΈ μ½”λ“λ¥Ό μ‚¬μ©ν•΄ κµ¬ν„λ `ISetoid<T>` ν΄λμ¤λ¥Ό ν…μ¤νΈν•  μ μλ‹¤.<br/>

-   `test/ISetoid-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const one = new Identity(1),
    anotherOne = new Identity(1);
const two = new Identity(2);

console.log(one.equals(anotherOne)); // true
console.log(one.equals(two)); // false
console.log(one.equals(1)); // false
console.log(one.equals(null)); // false
console.log(one.equals([1])); // false
```

λ³€μ `one`μ€ λ‘κ°™μ€ `Identity<number>` νƒ€μ… λ³€μμΈ `anotherOne`μ—λ§ `true`λ¥Ό λ°ν™ν•λ‹¤.<br/>
`equals` ν•¨μμ—μ„ λ§¤κ°λ³€μ `that`μ΄ `Identity`μ μΈμ¤ν„΄μ¤μ„μ„ νλ³„ν•κΈ° λ•λ¬Έμ΄λ‹¤.<br/>
λ§¤κ°λ³€μ `that`μ΄ `Identity` μΈμ¤ν„΄μ¤κ°€ μ•„λ‹λ©΄ λ¬΄μ΅°κ±΄ `false`λ¥Ό λ°ν™ν•κ² λλ‹¤.<br/>
λ§μ•½ `Identity`μ μΈμ¤ν„΄μ¤λΌλ©΄ `value` ν•¨μλ΅ κ°’μ„ κ°€μ Έμ™€ `==` μ—°μ‚°μλ΅ λΉ„κµν•κ² λλ‹¤.<br/>

### IFunctor\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ **ν‘ν„°**λ” `map`μ΄λΌλ” λ©”μ„λ“λ¥Ό μ κ³µν•λ” μΈν„°νμ΄μ¤λ‹¤.<br/>

-   `interfaces/IFunctor.ts`

```typescript
export interface IFunctor<T> {
    map<U>(fn: (x: T) => U);
}
```

**μΉ΄ν…κ³ λ¦¬ μ΄λ΅ **μ—μ„ **ν‘ν„°**λ” **μ—”λ„ ν‘ν„°**λΌλ” νΉλ³„ν• μ„±μ§μ„ λ§μ΅±ν•΄μ•Ό ν•λ‹¤.<br/>
Typescript 3.7.4 λ²„μ „μ—μ„λ” **μ—”λ„ν‘ν„°**λ¥Ό κµ¬ν„ν•  μ μκ² ν•λ” κµ¬λ¬Έμ„ μ κ³µν•μ§€ μ•λ”λ‹¤.<br/>
λ”°λΌμ„ `IFunctor`μ `map` λ©”μ„λ“μ λ°ν™ νƒ€μ…μ„ μƒλµν• μ΄μ λ” **μ—”λ„ ν‘ν„°**λ¥Ό κµ¬ν„ν•κΈ° μ„ν•΄μ„λ‹¤.<br/>

### μ—”λ„ν‘ν„°λ€?

**μ—”λ„**λ” λ‹¨μ–΄ μ•μ— λ¶™λ” μΌμΆ…μ μ ‘λ‘μ‚¬λ‹¤.<br/>
**μ—”λ„ν‘ν„°**λ” νΉμ • μΉ΄ν…κ³ λ¦¬μ—μ„ μ¶λ°ν•΄ **λ‹¤μ‹ μ¶λ° μΉ΄ν…κ³ λ¦¬λ΅ λ„μ°©**ν•λ” **ν‘ν„°**λ¥Ό μλ―Έν•λ‹¤.<br/>
μ•„λμ `Identity<T>`μ `map` λ©”μ„λ“μ κµ¬ν„ λ‚΄μ©μ€ **μ—”λ„ν‘ν„°**λ΅ λ™μ‘ν•κ² ν•λ” μ½”λ“λ‹¤.<br/>

-   `classes/Identtiy.ts`

```typescript
import { ISetoid, IFunctor } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IFunctor<T> {
    constructor(private _value: T) {}

    // IValualbe
    value() {
        return this._value;
    }

    // ISetoid
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }

    // IFunctor
    map<U>(fn: (x: T) => U) {
        return new Identity<U>(fn(this.value()));
    }
}
```

κ°’ νƒ€μ… `T`κ°€ `U`λ΅ λ°”λ€” μλ” μμ§€λ§ **μΉ΄ν…κ³ λ¦¬**λ” μ—¬μ „ν `Identity`μ— λ¨Έλ¬Όκ² ν•λ‹¤.<br/>

### IApply\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ **μ–΄ν”λΌμ΄**λ” **ν‘ν„°**μ΄λ©΄μ„ `ap` λ©”μ„λ“λ¥Ό μ κ³µν•λ” μΈν„°νμ΄μ¤λ‹¤.<br/>

-   `interfaces/IApply.ts`

```typescript
import { IFunctor } from "./IFunctor";

export interface IApply<T> extends IFunctor<T> {
    ap<U>(b: U);
}
```

`IApply<T>`λ¥Ό κµ¬ν„ν•λ” **μ»¨ν…μ΄λ„**λ” **κ°’ μ»¨ν…μ΄λ„**μ΄λ©° **κ³ μ°¨ ν•¨μμ μ»¨ν…μ΄λ„**λ΅λ„ λ™μ‘ν•λ‹¤.<br/>
μ•„λμ™€ κ°™μ€ ν…μ¤νΈ μ½”λ“λ΅ `IApply`μ λ™μ‘μ„ μ΄ν•΄ν•  μ μλ‹¤.<br/>

-   `test/IApply-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const add = (x) => (y) => x + y;
const id = new Identity(add);

console.log(id.ap(1).ap(2).value()); // 3
```

`Identity`λ” `add`λΌλ” **2μ°¨ κ³ μ°¨ ν•¨μ**λ¥Ό κ°’μΌλ΅ κ°€μ§€κ³  μλ‹¤.<br/>
`add`λ” **2μ°¨ κ³ μ°¨ ν•¨μ**μ΄λ―€λ΅ `ap` λ©”μ„λ“λ¥Ό λ‘ λ² νΈμ¶ν•΄ ν•¨μλ¥Ό λ™μ‘μ‹ν‚¨λ‹¤.<br/>

```typescript
import { ISetoid, IApply } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApply<T> {
    // ... μƒλµ ...
    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Identity.of<U>((f as Function)(b));
        }
    }
}
```

`IApply<T>` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” `Identity` ν΄λμ¤μ `ap` λ©”μ„λ“λ” μ„μ™€ κ°™λ‹¤.<br/>

### IApplicative\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ **μ• ν”λ¦¬μ»¤ν‹°λΈ**λ” `Apply`λ©΄μ„ `of`λΌλ” ν΄λμ¤ λ©”μ„λ“λ¥Ό μ κ³µν•λ” μΈν„°νμ΄μ¤λ‹¤.<br/>

-   `interfaces/IApplicative.ts`

```typescript
import { IApply } from "./IApply";

export interface IApplicative<T> extends IApply<T> {
    // static of(value: T);
}
```

Typescript 3.7.4λ²„μ „μ—μ„λ” `interface`μ— μ •μ  λ©”μ„λ“λ¥Ό κµ¬ν„ν•μ§€ λ»ν•λ‹¤.<br/>
λ”°λΌμ„ μ„μ™€ κ°™μ΄ μ£Όμ„ μ²λ¦¬λ¥Ό ν• ν›„ `Identity` ν΄λμ¤μ— `of` λ©”μ„λ“λ¥Ό κµ¬ν„ν•΄μ•Ό ν•λ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IApplicative } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApplicative<T> {
    // ... μƒλµ ...
    static of<T>(value: T): Identity<T> {
        return new Identity<T>(value);
    }
}
```

λν• 3.7.4 λ²„μ „μ Typescriptλ” μ •μ  λ©”μ„λ“μ λ°ν™ νƒ€μ…μ— `this`λ¥Ό μ‚¬μ©ν•  μ μ—†λ‹¤.<br/>
λ”°λΌμ„ `IApply`μ `of` λ©”μ„λ“μ λ°ν™ νƒ€μ…μ„ μƒλµν•΄ κµ¬ν„ν•μ€λ‹¤.<br/>

### IChian\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ **μ²΄μΈ**μ€ `Apply`λ©΄μ„ `chain`μ΄λΌλ” λ©”μ„λ“λ¥Ό κµ¬ν„ν•λ” μΈν„°νμ΄μ¤λ‹¤.<br/>

-   `interfaces/chain.ts`

```typescript
import { IApply } from "./IApply";

export interface IChain<T> extends IApply<T> {
    chain<U>(fn: (T) => U);
}
```

**λ¨λ‚λ“** νΉμ„±μ— λ”°λΌ `chain`μ€ `U` νƒ€μ…μ„ λ°ν™ν•μ§€ μ•μ„ μ μμ–΄ λ°ν™ νƒ€μ…μ„ μ§€μ •ν•μ§€ μ•μ•λ‹¤.<br/>
**μ²΄μΈ**μ `chain` λ©”μ„λ“λ” **ν‘ν„°**μ `map`κ³Ό λ‹¬λ¦¬ **μ—”λ„ν‘ν„°**λ΅ κµ¬ν„ν•΄μ•Όν•  μλ―Έκ°€ μ—†λ‹¤.<br/>
λ”°λΌμ„ μ•„λ μ½”λ“μ `chain`μ€ `map`κ³Ό ν•¨μ μ‹κ·Έλ‹μ²λ” κ°™μ§€λ§ κµ¬ν„ λ‚΄μ©μ€ μ΅°κΈ λ‹¤λ¥΄λ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IApplicative, IChain } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApplicative<T>, IChain<T> {
    // ... μƒλµ...
    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

**μ—”λ„ ν‘ν„°**μΈ `map`μ€ ν•­μƒ κ°™μ€ μΉ΄ν…κ³ λ¦¬μ— λ¨Έλ¬΄λ¥Έλ‹¤.<br/>
λ°λ©΄μ— `chain`μ€ μμ‹ μ΄ λ¨Έλ¬΄λ¥΄κ³  μ‹¶μ€ μΉ΄ν…κ³ λ¦¬λ¥Ό μ¤μ¤λ΅ μ •ν•΄μ•Ό ν•λ‹¤.<br/>

-   `test/IMap-IChain-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

console.log(
    Identity.of(1)
        .map((value) => `the count is ${value}`)
        .value()
); // the count is 1
console.log(
    Identity.of(1).chain((value) =>
        Identity.of(`the count is ${value}`).value()
    )
); // the count is 1
```

μ„μ `map`κ³Ό `chain`μ„ μ‚¬μ©ν•λ” μ½”λ“λ” κ°™μ€ κ²°κ³Όλ¥Ό λ³΄μ΄μ§€λ§ μ‚¬μ©λ²•μ— μ°¨μ΄κ°€ μλ‹¤.<br/>

### IMonad\<T> μΈν„°νμ΄μ¤μ™€ κµ¬ν„

**ννƒ€μ§€λλ“ κ·κ²©**μ—μ„ **λ¨λ‚λ“**λ” μ•„λμ²λΌ **μ²΄μΈ**κ³Ό **μ• ν”λ¦¬μ»¤ν‹°λΈ**λ¥Ό κµ¬ν„ν• κ²ƒμ΄λ‹¤.<br/>

-   `interfaces/IMonad.ts`

```typescript
import { IChain } from "./IChain";
import { IApplicative } from "./IApplicative";

export interface IMonad<T> extends IChain<T>, IApplicative<T> {}
```

μ΄μ  μ•„λμ™€ κ°™μ€ `Identity<T>` λ¨λ‚λ“κ°€ μ™„μ„± λμ—λ‹¤.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IMonad } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IMonad<T> {
    constructor(private _value: T) {}

    // IValualbe
    value() {
        return this._value;
    }

    // ISetoid
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }

    // IFunctor
    map<U>(fn: (x: T) => U) {
        return new Identity<U>(fn(this.value()));
    }

    // IApply
    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Identity.of<U>((f as Function)(b));
        }
    }

    // IApplicative
    static of<T>(value: T): Identity<T> {
        return new Identity<T>(value);
    }

    // IChain
    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

μ•„λ μ½”λ“λ” μ™„μ„±λ `Identity<T>` λ¨λ‚λ“κ°€ **μ™Όμ½ λ²•μΉ™**μ„ λ§μ΅±ν•λ”μ§€ ν…μ¤νΈν•λ” μ½”λ“λ‹¤.<br/>

-   `test/IMonad-Left-Law-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const a = 1;
const f = (a) => a * 2;

console.log(Identity.of(a).chain(f) == f(a)); // true
```

μ„μ μ½”λ“λ¥Ό μ‹¤ν–‰ν•λ©΄ `true`κ°€ μ¶λ ¥λ¨μ— λ”°λΌ `Identity<T>`κ°€ **λ¨λ‚λ“ μ™Όμ½ λ²•μΉ™**μ„ λ§μ΅±ν•λ‹¤.<br/>
μ•„λ μ½”λ“λ” `Identity<T>`κ°€ **μ¤λ¥Έμ½ λ²•μΉ™**μ„ λ§μ΅±ν•λ”μ§€ ν…μ¤νΈν•λ” λ‚΄μ©μ΄λ‹¤.<br/>

-   `test/IMonad-Right-Law-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const m = Identity.of(1);

console.log(m.chain(Identity.of).equals(m)); // true
```

μ„μ μ½”λ“μ κ²°κ³Ό μ—­μ‹ `true`κ°€ μ¶λ ¥λλ―€λ΅ `Identity<T>`κ°€ **μ¤λ¥Έμ½ λ²•μΉ™**μ„ λ§μ΅±ν•λ‹¤.<br/>
λ”°λΌμ„ `Identity<T>`λ” **μ¤λ¥Έμ½ λ²•μΉ™**κ³Ό **μ™Όμ½ λ²•μΉ™** λ¨λ‘ λ§μ΅±ν•λ―€λ΅ μ •μƒμ μΈ **λ¨λ‚λ“**λ‹¤.<br/>
μ•„λ μ½”λ“λ” `Identity` νƒ€μ… κ°μ²΄μ λ©”μ„λ“λ“¤μ„ λ©”μ„λ“ μ²΄μΈ ν•νƒλ΅ νΈμ¶ν•λ‹¤.<br/>

-   `test/IMonad-Method-Chain-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

type IPerson = { name: string; age: number };
const jack = Identity.of(["Jack", 32]);

console.log(
    jack
        .map(([name, age]) => ({ name, age }))
        .chain((p: IPerson) => Identity.of(p))
        .map(({ name, age }) => [name, age])
        .value()[0] == jack.value()[0]
); // true
```

**λ¨λ‚λ“**λ” μ„μ™€ κ°™μ΄ **μ„ μ–Έν• ν”„λ΅κ·Έλλ°**μ„ μ—Όλ‘μ— λ‘κ³  μ„¤κ³„λμ—λ‹¤.<br/>

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-3 Maybe λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„

### ν”„λ΅μ νΈ <span id="2">κµ¬μ„±</span>

μ•„λμ™€ κ°™μ΄ Typescriptλ¥Ό μ‚¬μ©ν•λ” node.js ν”„λ΅μ νΈλ¥Ό κµ¬μ„±ν•λ‹¤.<br/>
μ΄μ „ ν”„λ΅μ νΈμ—μ„ `ramda`μ™€ `node-fetch` ν¨ν‚¤μ§€λ¥Ό μ¶”κ°€ν•λ‹¤.<br/>
λν• 11-2μ—μ„ μ‘μ„±ν• `interfaces` ν΄λ”μ λ‚΄μ©μ„ κ·Έλ€λ΅ λ³µμ‚¬ν•΄ μ‚¬μ©ν•λ‹¤.<br/>

```shell
> npm init --y
> npm i -S ramda node-fetch
> npm i -D typescript ts-node @types/node @types/ramda @types/node-fetch
> mkdir -p src/test
> mkdir src/classes
```

`tsconfig.json` νμΌμ€ μ•„λμ™€ κ°™μ΄ μ„¤μ •ν•λ‹¤.<br/>

```typescript
{
    "compilerOptions": {
        "module": "CommonJS",
        "esModuleInterop": true,
        "target": "es5",
        "moduleResolution": "node",
        "outDir": "dist",
        "baseUrl": ".",
        "sourceMap": true,
        "downlevelIteration": true,
        "noImplicitAny": false,
        "paths": {
            "*": ["node_modules/*"]
        }
    },
    "include": ["src/**/*"]
}
```

κΈ°μ΅΄μ— μ‚¬μ©ν–λ `tsconfig.json` νμΌ μ„¤μ •λ“¤κ³Ό λ™μΌν•κ² μ„¤μ •ν•μ€λ‹¤.<br/>

### Maybe λ¨λ‚λ“λ€?

`Maybe`λ” μ¤λ¥μΌ λ•μ™€ μ •μƒμ μΌ λ• λ¨λ‘ κ³ λ ¤ν•λ©° μ½”λ“λ¥Ό κ°„κ²°ν•κ² μ‘μ„±ν•  μ μκ² ν•΄μ¤€λ‹¤.<br/>
μ¦‰, `Maybe`λ” **λ°μ΄ν„°μ μ λ¬΄**μ— λ”°λΌ μ½”λ“κ°€ μ μ ν•κ² λ™μ‘ν•λ„λ΅ μ„¤κ³„λμ—λ‹¤.<br/>
`Maybe`λ” ν•μ¤μΌ `Prelude` ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬μ—μ„ μ κ³µν•λ” **λ¨λ‚λ“**λ‹¤.<br/>
μ•μ—μ„ λ§λ“  `Option` νƒ€μ…μ„ μ΄μ©ν•΄ μ™„μ „ν• **λ¨λ‚λ“**λ΅ λ™μ‘ν•λ” `Maybe`λ¥Ό μ‘μ„±ν•λ‹¤.<br/>
`Maybe` λ¨λ‚λ“λ” `Option`μ `Some`, `None`κ³Ό λΉ„μ·ν• `Just`μ™€ `Nothing`μ΄λΌλ” νƒ€μ…μ„ μ κ³µν•λ‹¤.<br/>

```typescript
export class Maybe<T> {
    static Just<U>(value: U) {
        return new Just<U>(value);
    }
    static Nothing = new Nothing();
}
```

`Maybe`λ” κ·Έ μμ²΄κ°€ λ¨λ‚λ“κ°€ μ•„λ‹λΌ, `Maybe`κ°€ μ κ³µν•λ” `Just<T>`μ™€ `Nothing` νƒ€μ…μ΄ **λ¨λ‚λ“**λ‹¤.<br/>
`Maybe`μ μ΄λ° μ„¤κ³„ λ©μ μ€ μ½”λ“μ μ•μ •μ„±μ„ ν•¨μν• λ°©μ‹μΌλ΅ λ³΄μ¥ν•κΈ° μ„ν•΄μ„λ‹¤.<br/>
μλ¥Ό λ“¤μ–΄ Typescriptλ” μλ¥Ό `0`μΌλ΅ λ‚λ„λ©΄ μμ™Έλ¥Ό λ°μƒμ‹ν‚¤μ§€ μ•κ³  `Infinity`κ°’μ„ λ°ν™ν•λ‹¤.<br/>
`Infinity`λ” `number` νƒ€μ…μ κ°’μ΄λ―€λ΅ ν”„λ΅κ·Έλ¨μ΄ μ •μƒ μΆ…λ£λμ§€λ” μ•μ§€λ§ νΌλ€μ„ μ¤„ μ μλ‹¤.<br/>
μ΄μ²λΌ `undefined`, `Infinity` λ“±μ κ°’μ΄ μƒκΈΈ λ• `Maybe`λ¥Ό μ‚¬μ©ν•λ©΄ ν¨μ¨μ μΌλ΅ μ½”λ“λ¥Ό μ‘μ„±ν•  μ μλ‹¤.<br/>

```typescript
import { Maybe, IMaybe } from "../classes/Maybe";

const divide = (a: number) => (b: number): IMaybe<number> =>
    b ? Maybe.Just(a / b) : Maybe.Nothing;
```

μ„μ μ½”λ“λ” `b`μ κ°’μ΄ `undefined`, `null`, `0`μ΄ μ•„λ‹ λ•λ” `Maybe.Just(a / b)`κ°€ λ°ν™λλ‹¤.<br/>
ν•μ§€λ§ κ·Έ λ°λ€λ΅ `undefined`, `null`, `0`μΌ λ•λ” `Maybe.Nothing`μ΄ λ°ν™λλ‹¤.<br/>
λ”°λΌμ„ `divide` ν•¨μλ¥Ό μ‚¬μ©ν•λ” μ•„λ μ½”λ“λ” κ°„κ²°ν•λ©΄μ„λ„ μ•μ •μ„±μ„ ν•΄μΉμ§€ μ•κ²λλ‹¤.<br/>

```typescript
import * as R from "ramda";

console.log(divide(1)(1).map(R.add(1)).getOrElse(0)); // 2
console.log(divide(1)(0).map(R.add(1)).getOrElse(0)); // 0
```

`divide(1)(1)`λ” `Just(1 / 1)`μ΄ λ°ν™ν• κ°’μ„ `R.add(1)`μ— λ”ν•΄ `2`λ¥Ό μ¶λ ¥ν•κ² λλ‹¤.<br/>
`divide(1)(0)`λ” `Nothing`μ„ λ°ν™ν•΄ `R.add(1)`κ°€ λ™μ‘ν•μ§€ μ•κ³  `getOrElse(0)`κ°€ λ°ν™ν• `0`μ„ μ¶λ ¥ν•λ‹¤.<br/>

### Maybe ν΄λμ¤ κµ¬μ΅°

`Maybe` ν΄λμ¤λ” Typescript μ–Έμ–΄μ νΉμ„±μ„ κ³ λ ¤ν•΄ μ•„λμ™€ κ°™μ΄ μ„¤κ³„ν•λ‹¤.<br/>

-   `classes/Maybe.ts`

```typescript
import { Just } from "./Just";
import { Nothing } from "./Nothing";
import { IMonad } from "../interfaces";
import { _IMaybe } from "./_IMaybe";

export class Maybe<T> {
    static Just<U>(value: U) {
        return new Just<U>(value);
    }
    static Nothing = new Nothing();
}

export type IMaybe<T> = _IMaybe<T> & IMonad<T>;
```

μ‘μ„±λμ§€ μ•μ€ `Just`, `Nothing`, `_IMaybe`λ” μ΄ν›„μ— κµ¬ν„ν•  μμ •μ΄λ‹¤.<br/>
`IMaybe<T>`λΌλ” νƒ€μ…μ„ λ‚΄λ³΄λ‚΄λ” κ²ƒμ€ Typescript μ–Έμ–΄μ νΉμ§•μ„ λ°μν• κ²ƒμ΄λ‹¤.<br/>

### Maybeκ°€ ν•¨μμ λ°ν™ νƒ€μ…μΌ λ•μ λ¬Έμ μ 

Typescript 3.7.4λ²„μ „μ€ `Just<number> | Nothing`κ³Ό κ°™μ€ ν•©μ§‘ν•© νƒ€μ…μ„ λ§λ‚λ©΄ μ¤λ¥κ°€ λ°μƒν•λ‹¤.<br/>

```typescript
import * as R from "ramda";
import { Just } from "../classes/Just";
import { Nothing } from "../classes/Nothing";
import { Maybe, IMaybe } from "../classes/Maybe";

const divide = (a: number) => (b: number): Just<number> | Nothing =>
    b ? Maybe.Just(a / b) : Maybe.Nothing;

console.log(divide(1)(1).map(R.add(1)).getOrElse(0)); // 2
console.log(divide(1)(0).map(R.add(1)).getOrElse(0)); // 0
```

-   λ°ν™ νƒ€μ…μ΄ `Just<number> | Nothing` μΌ λ• λ°μƒν•λ” μ¤λ¥

<img src="./images/4.png" width="450" height="auto">

ν•μ§€λ§ μ•„λμ™€ κ°™μ΄ `IMaybe`λΌλ” μΈν„°νμ΄μ¤λ¥Ό ν•¨μμ λ°ν™ νƒ€μ…μΌλ΅ μ‚¬μ©ν•λ©΄ μ •μƒ μ‘λ™ν•λ‹¤.<br/>

```typescript
import * as R from "ramda";
import { Maybe, IMaybe } from "../classes/Maybe";

const divide = (a: number) => (b: number): IMaybe<number> =>
    b ? Maybe.Just(a / b) : Maybe.Nothing;

console.log(divide(1)(1).map(R.add(1)).getOrElse(0)); // 2
console.log(divide(1)(0).map(R.add(1)).getOrElse(0)); // 0
```

λ”°λΌμ„ `Maybe` ν΄λμ¤λ” μ•„λ `_IMaybe`μ™€ `IMonad` μΈν„°νμ΄μ¤λ¥Ό ν•©ν• `IMaybe` νƒ€μ…μ„ μ κ³µν•λ‹¤.<br/>

-   `classes/_IMaybe.ts`

```typescript
export interface _IMaybe<T> {
    isJust(): boolean;
    isNothing(): boolean;
    getOrElse(defaultValue: T): T;
}
```

`Just`μ™€ `Nothing` ν΄λμ¤ λ¨λ‘ `_IMaybe`μ™€ `IMonad`λ¥Ό κµ¬ν„ν•κΈ° λ•λ¬Έμ— μ¤λ¥κ°€ λ°μƒν•μ§€ μ•λ”λ‹¤.<br/>

### Just λ¨λ‚λ“ κµ¬ν„

`Just` λ¨λ‚λ“λ” `Identity` λ¨λ‚λ“μ— `_IMaybe` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ‹¤.<br/>

-   `classes/Just.ts`

```typescript
import { IMonad } from "../interfaces";
import { _IMaybe } from "./_IMaybe";

export class Just<T> implements _IMaybe<T>, IMonad<T> {
    constructor(private _value: T) {}
    value(): T {
        return this._value;
    }

    static of<T>(value: T): Just<T> {
        return new Just<T>(value);
    }

    isJust() {
        return true;
    }
    isNothing() {
        return false;
    }
    getOrElse<U>(defaultValue: U) {
        return this.value();
    }

    map<U, V>(fn: (x: T) => U): Just<U> {
        return new Just<U>(fn(this.value()));
    }

    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Just.of<U>((f as Function)(b));
        }
    }

    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

λ‹¤λ§ `Identity` λ¨λ‚λ“μ™€ λ‹¬λ¦¬ `ISetoid` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•μ§€ μ•λ”λ‹¤.<br/>
μ΄λ” `Just`κ°€ `Nothing`μΌ λ•λ¥Ό κ³ λ ¤ν•΄ `value()`κ°€ μ•„λ‹ `getOrElse(0)` ν•νƒλ΅ λ™μ‘ν•κΈ° μ„ν•΄μ„λ‹¤.<br/>

### Nothing λ¨λ‚λ“ κµ¬ν„

`Nothing` λ¨λ‚λ“λ” `Just` λ¨λ‚λ“μ™€ λ‹¬λ¦¬ μ½”λ“λ¥Ό μ™„λ²½ν•κ² μ‹¤ν–‰μ‹ν‚¤μ§€ μ•λ” κ²ƒμ΄ λ©μ μ΄λ‹¤.<br/>

-   `classes/Nothing.ts`

```typescript
import { IMonad } from "../interfaces";
import { _IMaybe } from "./_IMaybe";

export class Nothing implements _IMaybe<null>, IMonad<null> {
    static of<T>(value: T = null): Nothing {
        return new Nothing();
    }

    isJust() {
        return false;
    }
    isNothing() {
        return true;
    }
    getOrElse<U>(defaultValue: U) {
        return defaultValue;
    }

    map<U, V>(fn: (x) => U): Nothing {
        return new Nothing();
    }

    ap<U>(b: U) {
        return new Nothing();
    }

    chain<U>(fn: (T) => U): Nothing {
        return new Nothing();
    }
}
```

μ„μ μ½”λ“λ” `divide(1)(0).map(R.add(1))` ν•νƒμ μ½”λ“κ°€ λΉ„μ •μƒμ μΌλ΅ λ™μ‘ν•μ§€ μ•κ² ν•λ‹¤.<br/>
λν• κ°€μ¥ λ§μ§€λ§‰μ— νΈμ¶λ `getOrElse(0)` λ©”μ„λ“μ κΈ°λ³Έκ°’μ„ λ°ν™ν•λ” κ²ƒμ„ λ©ν‘λ΅ν•λ‹¤.<br/>

### Justμ™€ Nothing λ¨λ‚λ“ λ‹¨μ„ ν…μ¤νΈ

`Just`λ” μ •μƒμ μΌ λ• λ™μ‘ν•λ” λ¨λ‚λ“μ΄λ―€λ΅ ν•­μƒ μ‹¤μ κ°’μ„ λ°ν™ν•΄μ•Ό ν•λ‹¤.<br/>
μ•„λ μ½”λ“λ” `Just`κ°€ μ •μƒμ μΌλ΅ λ™μ‘ν•λ©° `_IMaybe` μΈν„°νμ΄μ¤ κΈ°λ¥μ„ μ κ³µν•λ” κ²ƒμ„ λ³΄μ—¬μ¤€λ‹¤.<br/>

-   `test/Just-Test.ts`

```typescript
import * as R from "ramda";
import { Just } from "../classes/Just";

console.log(Just.of(100).isJust()); // true
console.log(Just.of(100).isNothing()); // false
console.log(Just.of(100).getOrElse(1)); // 100
console.log(Just.of(100).map(R.identity).getOrElse(1)); // 100
console.log(Just.of(R.identity).ap(100).getOrElse(1)); // 100
console.log(Just.of(100).chain(Just.of).getOrElse(1)); // 100
```

`Nothing` λ¨λ‚λ“λ” `Just`μ™€ λ‹¬λ¦¬ μμ‹ μ λ¨λ‚λ“ κ΄€λ ¨ μ½”λ“λ¥Ό λ™μ‘μ‹ν‚¤μ§€ λ§μ•„μ•Ό ν•λ‹¤.<br/>
λν• `undefined`λ‚ `null`, `Nan`, `Infinity`μ™€ κ°™μ€ κ°’μ„ λ°ν™ν•΄μ„λ„ μ•λλ‹¤.<br/>

-   `test/Nothing-Test.ts`

```typescript
import { Nothing } from "../classes/Nothing";
import { Just } from "../classes/Just";

console.log(Nothing.of().isJust()); // false
console.log(Nothing.of().isNothing()); // true
console.log(Nothing.of().getOrElse(1)); // 1
console.log(
    Nothing.of()
        .map((x) => x + 1)
        .getOrElse(1)
); // 1
console.log(Nothing.of().ap(1).getOrElse(1)); // 1
console.log(Nothing.of().chain(Just.of).getOrElse(1)); // 1
```

μ„μ™€ κ°™μ΄ `Nothing` λ¨λ‚λ“λ¥Ό μ‚¬μ©ν•λ©΄ `getOrElse`λ΅ λ„κ²¨μ§„ κΈ°λ³Έκ°’λ§ λ°ν™ν•λ” κ²ƒμ„ λ³Ό μ μλ‹¤.<br/>

### Maybe ν…μ¤νΈ

μ›Ή λΈλΌμ°μ €μ—μ„ API μ„λ²„μ—μ„ λ°μ΄ν„°λ¥Ό κ°€μ Έμ¬ λ•λ” `fetch`λΌλ” ν•¨μλ¥Ό μ‚¬μ©ν•λ‹¤.<br/>
`fetch` ν•¨μλ” μ›Ή λΈλΌμ°μ €μ—μ„λ” μ κ³µν•μ§€λ§ `Node.js` ν™κ²½μ—μ„λ” μ κ³µν•μ§€ μ•λ”λ‹¤.<br/>
`node-fetch` ν¨ν‚¤μ§€λ¥Ό μ„¤μΉν•λ©΄ `Node.js` ν™κ²½μ—μ„λ„ `fetch`ν•¨μλ¥Ό μ‚¬μ©ν•  μ μλ‹¤.<br/>
`fetch` ν•¨μλ” μ•„λμ²λΌ λ¬Έμμ—΄λ΅ λ URLμ„ μ…λ ¥ λ§¤κ°λ³€μλ΅ νΈμ¶ν•΄ `Promise` κ°μ²΄λ¥Ό λ°ν™ν•λ‹¤.<br/>

```typescript
fetch(url: string): Promise
```

`fetch`κ°€ λ°ν™ν• `Promise` κ°μ²΄λ” `then` λ©”μ„λ“λ¥Ό νΈμ¶ν•΄ μ‘λ‹µ κ°μ²΄ μ–»μ„ μ μλ‹¤.<br/>
μ–»μ€ μ‘λ‹µ κ°μ²΄λ” `text`, `blob`, `json`κ³Ό κ°™μ€ λ©”μ„λ“λ¥Ό νΈμ¶ν•΄ μ‹¤μ  λ°μ΄ν„°λ¥Ό μ–»μ„ μ μλ‹¤.<br/>
μ•„λ μ½”λ“λ” `fetch` ν•¨μλ¥Ό μ‚¬μ©ν•΄ `JSON` ν¬λ§·μΌλ΅λ λ°μ΄ν„°λ¥Ό κ°€μ Έμ¤λ” μμ‹λ‹¤.<br/>

-   `fetchJokes.ts`

```typescript
import fetch from "node-fetch";

export const fetchJokes = <T>() =>
    new Promise<T>((resolve, reject) => {
        const jokeUrl = "https://api.icndb.com/jokes/random/5?limitTo=[nerdy]";

        fetch(jokeUrl)
            .then((res) => res.json())
            .then((fetchResult: unknown) => resolve(fetchResult as T))
            .catch((e: Error) => reject(e));
    });
```

`jokeUrl` λ³€μμ— λ‹΄κΈ΄ νμ΄μ§€λ” `JSON` ν¬λ§·μΌλ΅ λ°μ΄ν„°λ¥Ό λ³΄λ‚΄λ―€λ΅ `json` λ©”μ„λ“λ¥Ό νΈμ¶ν•λ‹¤.<br/>
μ΄λ ‡κ² μ–»μ€ μ‹¤μ  `JSON` λ°μ΄ν„°λ” κµ¬μ²΄μ μΈ νƒ€μ…μ„ μ• μ μ—†μΌλ―€λ΅ `unknown`μΌλ΅ ν•΄μ„ν•΄ μ–»λ”λ‹¤.<br/>
μ•„λμ μ½”λ“λ¥Ό ν†µν•΄ μ‘μ„±ν• `fetchJokes` ν•¨μλ¥Ό ν…μ¤νΈν•  μ μλ‹¤.<br/>

-   `test/FetchJokes-Test.ts`

```typescript
import { fetchJokes } from "../fetchJokes";

fetchJokes()
    .then((result) => console.log(result))
    .catch((e: Error) => console.log(e.message));
```

μ„μ μ½”λ“λ¥Ό μ‹¤ν–‰ν•λ©΄ μ•„λμ™€ κ°™μ€ ν•νƒμ `JSON` ν¬λ§·μ λ°μ΄ν„°κ°€ μ¶λ ¥λλ‹¤.<br/>

<img src="./images/5.png" width="600" height="auto">

μ„μ ν™”λ©΄μΌλ΅λ¶€ν„° λ°μ΄ν„°λ” μ•„λμ™€ κ°™μ€ ν•νƒμ νƒ€μ…μ„ κ°€μ§€κ³  μμμ„ μ• μ μλ‹¤.<br/>

```typescript
{
    type: string,
    value: {
        id: number,
        joke: string,
        category: string[][]
    }
}
```

μ•„λ μ½”λ“λ” `fetchJokes` ν•¨μμ κ²°κ³Όλ¥Ό κ°€κ³µν•΄ λ°μ΄ν„° μ¤‘ ν•λ‚λ¥Ό λλ¤ν•κ² μ„ νƒν•κ² ν•λ” μ½”λ“λ‹¤.<br/>

-   `getRandomJoke.ts`

```typescript
import { fetchJokes } from "./fetchJokes";

const random = (max: number) => Math.floor(Math.random() * max);

export type FetchResult = { type: string; value: JokeType[] };
export type JokeType = {
    id: number;
    joke: string;
    category: string[];
};

export const getRandomJoke = () =>
    new Promise<JokeType>((resolve, reject) => {
        fetchJokes<FetchResult>()
            .then((result: FetchResult) => {
                let array: JokeType[] = result.value;
                resolve(array[random(array.length)]);
            })
            .catch((e: Error) => reject(e));
    });
```

μ•„λ μ½”λ“λ” μ‘μ„±ν• `getRandomJoke` ν•¨μλ¥Ό ν…μ¤νΈν•λ” μ½”λ“λ‹¤.<br/>

-   `test/GetRandomJoke-Test.ts`

```typescript
import * as R from "ramda";
import { getRandomJoke, JokeType } from "../getRandomJoke";

getRandomJoke()
    .then((JokeItem: JokeType) => {
        const joke = R.view(R.lensProp("joke"))(JokeItem);
        console.log(joke);
    })
    .catch((e: Error) => console.log(e.message));
```

`ramda` λΌμ΄λΈλ¬λ¦¬μ **λ μ¦** κΈ°λ¥μ„ μ‚¬μ©ν•΄ `joke` μ†μ„±κ°’λ§ μ–»μ–΄ μ¶λ ¥ν•λ‹¤.<br/>
`getRandomJoke` ν•¨μλ” `then`κ³Ό `catch`λ¬Έμ„ μ‚¬μ©ν•΄ μ½”λ“κ°€ μ΅°κΈ λ²κ±°λ΅­λ‹¤.<br/>
μ•„λμ™€ κ°™μ΄ `getRandomJoke` ν•¨μλ΅ μ–»μ€ κ°’μ„ `Maybe` λ¨λ‚λ“λ¥Ό μ‚¬μ©ν•΄ κ°€κ³µν•  μ μλ‹¤.<br/>

-   `getJokeAsMaybe.ts`

```typescript
import * as R from "ramda";
import { getRandomJoke, JokeType } from "./getRandomJoke";
import { IMaybe, Maybe } from "./classes/Maybe";

const _getJokeAsMaybe = async () => {
    const jokeItem: JokeType = await getRandomJoke();
    const joke = R.view(R.lensProp("joke"))(jokeItem);
    return joke;
};

export const getJokeAsMaybe = () =>
    new Promise<IMaybe<string>>((resolve, reject) => {
        _getJokeAsMaybe()
            .then((joke: string) => resolve(Maybe.Just(joke)))
            .catch((e) => resolve(Maybe.Nothing));
    });

export { IMaybe, Maybe };
```

μ„μ™€ κ°™μ΄ κµ¬ν„λ `getJokeAsMaybe`λ” μ—λ¬κ°€ λ°μƒν•΄λ„ `reject`λ€μ‹  `Maybe.Nothing`μ„ λ°ν™ν•λ‹¤.<br/>
μ‘μ„±ν• `getJokeAsMaybe` ν•¨μλ” μ•„λμ™€ κ°™μ΄ ν…μ¤νΈν•  μ μλ‹¤.<br/>

-   `test/GetJokeAsMaybe-Test.ts`

```typescript
import { getJokeAsMaybe, IMaybe } from "../getJokeAsMaybe";

(async () => {
    const joke: IMaybe<string> = await getJokeAsMaybe();
    console.log(joke.getOrElse("something wrong"));
})();
```

μ„μ™€ κ°™μ΄ `Maybe` λ¨λ‚λ“λ¥Ό μ‚¬μ©ν•΄ `then`, `catch` κµ¬λ¬Έμ„ μ‚¬μ©ν•μ§€ μ•κ³  μ½”λ“λ¥Ό μ‘μ„±ν•  μ μλ‹¤.<br/>
`Maybe` λ¨λ‚λ“λ” μ΄μ²λΌ **μ¤λ¥μΌ λ•μ™€ μ •μƒμΌ λ•λ¥Ό λ¨λ‘ κ³ λ ¤**ν•λ©° **κ°„κ²°ν•κ² μ½”λ“λ¥Ό μ‘μ„±**ν•  μ μλ‹¤.<br/>

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-4 Validation λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-5 IO λ¨λ‚λ“ μ΄ν•΄μ™€ κµ¬ν„

[[π”μ„λ΅κ°€κΈ°]](#11μ¥-λ¨λ‚λ“)&nbsp; / &nbsp;[[π”™λ’¤λ΅κ°€κΈ°]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
