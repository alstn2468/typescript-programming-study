# 10장 제네릭 프로그래밍

<details><summary>Table of Contents</summary>

-   10-1 제네릭 타입 이해하기 [:link:](#10-1-제네릭-타입-이해하기)
    -   제네릭 타입 [:link:](#제네릭-타입)
    -   제네릭 사용하기 [:link:](#제네릭-사용하기)
-   10-2 제네릭 타입 제약 [:link:](#10-2-제네릭-타입-제약)
    -   제네릭 타입 제약 [:link:](#제네릭-타입-제약)
    -   new 타입 제약 [:link:](#new-타입-제약)
    -   인덱스 타입 제약 [:link:](#인덱스-타입-제약)
-   10-3 대수 데이터 타입 [:link:](#10-3-대수-데이터-타입)
    -   대수 데이터 타입 [:link:](#대수-데이터-타입)
    -   합집합 타입 [:link:](#합집합-타입)
    -   교집합 타입 [:link:](#교집합-타입)
    -   합집합 타입 구분하기 [:link:](#합집합-타입-구분하기)
    -   식별 합집합 구문 [:link:](#식별-합집합-구문)
-   10-4 타입 가드 [:link:](#10-4-타입-가드)
    -   클래스와 합집합 타입 [:link:](#클래스와-합집합-타입)
    -   instanceof 연산자 [:link:](#instanceof-연산자)
    -   타입 가드 [:link:](#타입가드)
    -   is 연산자를 활용한 사용자 정의 타입 가드 함수 제작 [:link:](#is-연산자를-활용한-사용자-정의-타입-가드-함수-제작)
-   10-5 F-바운드 다형성 [:link:](#10-5-f-바운드-다형성)
-   10-6 nullable 타입과 프로그램 안정성 [:link:](#10-6-nullable-타입과-프로그램-안정성)

</details>

## 10-1 제네릭 타입 이해하기

### 제네릭 타입

**제네릭 타입**은 인터페이스나, 클래스, 합수, 타입 별칭 등에 사용할 수 있는 기능이다.<br/>
해당 심볼의 타입을 미리 지정하지 않고 다양한 타입에 대응하려고 할 때 사용한다.<br/>

```typescript
interface IValuable<T> {
    value: T;
}
```

위의 `IValueable` 인터페이스는 `T` 타입의 `value` 라는 속성을 갖는다.<br/>
위와 같이 타입을 `string`, `number`등으로 정하지 않고 `T`로 지정해 **제네릭 타입**으로 만들 수 있다.<br/>
**제네릭 타입**을 인터페이서 지정할 때 위와 같이 인터페이스 이름 뒤에 `<T>`와 같이 표기한다.<br/>

```typescript
function identity<T>(arg: T): T {
    return arg;
}

type IValuable<T> = {
    value: T;
};

class Valueable<T> {
    constructor(public value: T) {}
}
```

위의 코드는 클래스와 함수, 타입 별칭에 각각 **제네릭 타입**을 사용하는 예시다.<br/>

### 제네릭 사용하기

아래와 같이 `T` 타입의 `value` 속성을 갖는 `IValuable` 인터페이스를 작성한다.<br/>

-   `IValuable.ts`

```typescript
export interface IValuable<T> {
    value: T;
}
```

제네릭 인터페이스 `IValuable<T>`를 구현하는 **제네릭 클래스**는 타입 변수 `T`를 갖는다.<br>
구현한 **제네릭 클래스**는 가지고 있는 타입 변수를 인터페이스의 제네릭 타입 변수로 넘길 수 있다.<br/>

-   `Valuable.ts`

```typescript
import { IValuable } from "./IValuable";

export class Valuable<T> implements IValuable<T> {
    constructor(public value: T) {}
}

export { IValuable };
```

**제네릭 함수**는 타입 변수 `T`를 제네릭 인터페이스의 타입 변수로 넘기는 형태로 구현할 수 있다.<Br/>

-   `printValue.ts`

```typescript
import { IValuable, Valuable } from "./Valuable";

export const printValue = <T>(o: IValuable<T>): void => console.log(o.value);
export { IValuable, Valuable };
```

이렇게 만든 제네릭 함수 `printValue`는 아래 처럼 다양한 타입을 대상으로 동작할 수 있다.<br/>

-   `printValue-Test.ts`

```typescript
import { printValue, Valuable } from "./PrintValue";

printValue(new Valuable<number>(1)); // 1
printValue(new Valuable<boolean>(true)); // true
printValue(new Valuable<string>("hello")); // hello
printValue(
    new Valuable<number[]>([1, 2, 3])
); // [ 1, 2, 3 ]
```

또한 아래와 같이 타입 변수 부분을 생략해도 스스로 추론해 제네릭 타입을 찾아낸다.<br/>

-   `printValue-Test2.ts`

```typescript
import { printValue, Valuable } from "./PrintValue";

printValue(new Valuable(1)); // 1
printValue(new Valuable(true)); // true
printValue(new Valuable("hello")); // hello
printValue(new Valuable([1, 2, 3])); // [ 1, 2, 3 ]
```

제네릭 타입을 지정하지 않아도 동일한 결과를 출력하는 것을 볼 수 있다.<br/>

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-2 제네릭 타입 제약

### 제네릭 타입 제약

**제네릭 타입 제약**은 타입 변수에 적용할 수 있는 **타입의 범위를 제한하는 기능**을 한다.<br/>
Typescript에서 제네릭 함수의 타입을 제한하고 싶을 때는 아래와 같은 구문을 사용한다.<br/>

```typescript
<최종 타입1 extend 타입1, 최종 타입2 extend 타입2>(a: 최종 타입1, b: 최종 타입2, ...) {}
```

아래의 `IValuable<T>`는 `T` 타입 `value` 속성을 갖는 제네릭 인터페이스다.<br/>

-   `IValuable.ts`

```typescript
export interface IValuable<T> {
    value: T;
}
```

아래의 `printValueT` 함수는 앞의 `printValue` 함수와 구현 방식이 조금 다르다.<br/>
`printValueT` 함수는 **제네릭 타입 제약** 구문을 사용해 구현되어 있다.<br/>

-   `printValueT.ts`

```typescript
import { IValuable, Valuable } from "./Valuable";

export const printValueT = <Q, T extends IValuable<Q>>(o: T): void =>
    console.log(o.value);
export { IValuable, Valuable };
```

`printValue`와 비교하여 매개변수의 타입을 어떤 방식으로 제약하는지만 다르다.<br/>

```typescript
import { printValueT } from "./printValueT";
import { Valuable } from "./Valuable";

printValueT(new Valuable(1)); // 1
printValueT({ value: true }); // true
```

출력 결과는 `printValue` 함수를 사용한 것과 동일한 것을 볼 수 있다.<br/>
위의 `printValueT` 함수는 아래와 같이 구현하면 안된다.<br/>

```typescript
export const printValueT = <T extends IValuable<T>>(o: T) =>
    console.log(o.value);
```

`o`의 `T` 입장에서 타입 `T`는 `IValuable<T>`이므로 `IValuable <IValuable<T>>`와 같이 해석되기 때문이다.<br/>

### new 타입 제약

팩토리 함수는 `new` 연산자를 사용해 객체를 생성하는 기능을 하는 함수를 의미한다.<br/>
팩토리 함수는 객체를 생성하는 방법이 복잡할 때 단순화하려는 목적으로 구현한다.<br/>

```typescript
const create = <T>(type: T): T => new type();
```

위 코드에서 `create` 함수의 매개변수 `type`은 실제로 **타입**이다.<br/>
따라서 `type` 변수의 타입 주석으로 명시한 `T`는 **타입의 타입**에 해당한다.<br/>

<img src="./images/1.png" width="350" height="auto">

하지만 Typescript는 타입의 타입을 허용하지 않으므로 위와 같은 오류가 발생한다.<br/>
Typescript의 창시자인 아네르스 하일스베르는 C# 언어의 창시자이기도 하다.<br/>
아래 코드에서 `{new(): T}` 구문은 C#에서 볼 수 있는 구문과 매우 유사하다.<br/>

```typescript
const create = <T extends { new (): T }>(type: T): T => new type();
```

하일스베르는 타입의 타입에 해당하는 구문을 만들지 않고 C# 언어에서의 구문을 빌려 사용하였다.<br/>
`create` 함수의 타입 제약 구문은 `{}`로 `new()` 부분을 감싸서 메서드 형태로 표현했다.<br/>
이 구문은 아래와 같이 `{}`를 없앤 좀 더 간결한 문법으로 표현할 수도 있다.<br/>

```typescript
const create = <T>(type: new () => T): T => new type();
```

결론적으로 `{ new(): T }`와 `new() =>` 는 같은 의미를 갖는다.<br/>
`new` 연산자를 `type`에 적용하며 `type`의 생성자로 인자를 전달하려면 아래와 같이 사용한다.<br/>

```typescript
const create = <T>(type: { new (...args): T }, ...args): T => new type(...args);
```

아래 코드는 `Date`와 `Point` 인스턴스를 **타입 제약**을 설정한 `create`함수로 생성하는 예시다.<br/>

-   `create.ts`

```typescript
export const create = <T>(type: { new (...args): T }, ...args): T =>
    new type(...args);
```

-   `create-Test.ts`

```typescript
import { create } from "./create";

class Point {
    constructor(public x: number, public y: number) {}
}
[create(Date), create(Point, 0, 0)].forEach((s) => console.log(s));
// 2020-07-30T06:16:53.363Z
// Point { x: 0, y: 0 }
```

위의 `create` 함수를 호출해 보면 클래스의 인스턴스가 정상적으로 생성되는 것을 볼 수 있다.<br/>

### 인덱스 타입 제약

객체의 일정 속성들만 추려 좀 더 단순한 객체를 만들어야 할 때가 있다.<br/>
`pick` 함수는 `obj` 객체에서 `name`과 `age` 두 속성만 추출해 간단한 형태를 만드려 한다.<br/>

```typescript
const obj = { name: "Jane", age: 22, city: "Seoul", country: "Korea" };
pick(obj, ["name", "age"]);
```

위에서 사용한 `pick` 함수는 아래와 같이 구현할 수 있다.<br/>

-   `pick.ts`

```typescript
export const pick = (obj, keys) =>
    keys
        .map((key) => ({ [key]: obj[key] }))
        .reduce((result, value) => ({ ...result, ...value }), {});
```

아래의 코드를 실행하면 `pick` 함수가 `name`과 `age` 속성과 값을 추출해주는 것을 볼 수 있다.<br/>

-   `pick-Test.ts`

```typescript
import { pick } from "./pick";

const obj = { name: "Jane", age: 22, city: "Seoul", country: "Korea" };
console.log(pick(obj, ["name", "age"])); // { name: 'Jane', age: 22 }
console.log(pick(obj, ["name", "agge"])); //{ name: 'Jane', agge: undefined }
```

하지만 `pick(obj, ["name", "agge"])`와 같이 오타가 발생하면 엉뚱한 결과가 나온다.<br/>
Typescript는 이러한 상황을 방지하기 위해 `keyof T` 형태로 **타입 제약**을 설정할 수 있다.<br/>
`keyof T` 형태 같은 타입 제약을 **인덱스 타입 제약**이라고 한다.<br/>

```typescript
<T, K extends keyof T>
```

아래 코드에서 `pick` 함수는 `keys` 매개변수에 각각 `T`와 `K`라는 타입 변수를 적용했다.<br/>

```typescript
export const pick = <T, K>(obj: Text, keys: K[]) =>
    keys
        .map((key) => ({ [key]: obj[key] }))
        .reduce((result, value) => ({ ...result, ...value }), {});
```

하지만 이 코드는 `K` 타입에 타입 제약을 설정하지 않았으므로 아래와 같은 오류가 발생한다.<br/>

<img src="./images/2.png" width="400" height="auto"><br/>
<img src="./images/3.png" width="400" height="auto">

위와 같은 오류를 해결하려면 타입 `K`가 `T`의 속성 이름이라는 것을 알려줘야 한다.<br/>
`keyof T` 구문으로 타입 `K`가 타입 `T`의 속성 이름이라고 **인덱스 타입 제약**을 설정한다.<br/>

-   `pickTwo.ts`

```typescript
export const pickTwo = <T, K extends keyof T>(obj: T, keys: K[]) =>
    keys
        .map((key) => ({ [key]: obj[key] }))
        .reduce((result, value) => ({ ...result, ...value }), {});
```

아래 코드를 실행하면 **인덱스 타입 제약**을 설정한 `pickTwo` 함수를 테스트할 수 있다.<br/>

-   `pickTwo-Test.ts`

```typescript
import { pickTwo } from "./pickTwo";

const obj = { name: "Jane", age: 22, city: "Seoul", country: "Korea" };
console.log(pickTwo(obj, ["name", "age"])); // { name: 'Jane', age: 22 }
console.log(pickTwo(obj, ["name", "agge"])); // Error
```

`pickTwo(obj, ["name", "agge"])` 같이 잘못 사용했을때 작성 시점에 오류를 탐지할 수 있다.<br/>

<img src="./images/4.png" width="450" height="auto">

위와 같이 컴파일 이전에 `obj`의 속성이 아닌 `agge`를 사용할 수 없는 것을 볼 수 있다.<br/>

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-3 대수 데이터 타입

### 대수 데이터 타입

객체지향 프로그래밍 언어에서 **ADT**는 **추상 데이터 타입**을 의미한다.<br/>
하지만 함수형 프로그래밍 언어에서는 **대수 데이터 타입**을 의미한다.<br/>
Typescript에서 **대수 데이터 타입**은 **합집합 타입**과 **교집합 타입**이 있다.<br/>
객체지향 언어는 **상속**에 기반을 두고 타입을 분류하는 경향이 있다.<br/>
상속에만 의존하면 `true`와 `false`단 두가지 값을 갖는 `boolean`과 같은 타입을 만들기 어렵다.<br/>
이 때문에 함수형 언어들은 상속에 의존하는 타입보다 **대수 데이터 타입**을 선호한다.<br/>

### 합집합 타입

**합집합 타입**은 **또는**의 의미인 `|` 기호로 다양한 타입을 연결해서 만든 타입을 말한다.<br/>
아래 코드에셔 변수 `ns`의 타입인 `NumberOrString`은 `number`나 `string` 타입이다.<br/>

-   `UnionType.ts`

```typescript
type NumberOrString = number | string;
let ns: NumberOrString = 1;
ns = "Hello";
```

따라서 위와 같이 `1`과 같은 수와 `hello`와 같은 문자열을 모두 담을 수 있다.<br/>

### 교집합 타입

**교집합 타입**은 **그리고**의 의미인 `&` 기호로 다양한 타입을 연결해서 만든 타입을 말한다.<br/>
**교집합 타입**의 대표적인 예시는 두 개의 객체를 통합해서 새로운 객체를 만드는 것이다.<br/>
아래 코드에서 `mergeObjects` 함수는 타입 `T`와 `U` 객체를 결합해 새로운 객체를 만든다.<br/>

-   `mergeObjects.ts`

```typescript
export const mergeObjects = <T, U>(a: T, b: U): T & U => ({ ...a, ...b });
```

-   `mergeObjects-Test.ts`

```typescript
import { mergeObjects } from "./mergeObjects";

type INameable = { name: string };
type IAgeable = { age: number };

const nameAndAge: INameable & IAgeable = mergeObjects(
    { name: "Jack" },
    { age: 32 }
);
console.log(nameAndAge); // { name: 'Jack', age: 32 }
```

`INameable` 타입 객체와 `IAgeable` 타입 객체을 `mergeObjects` 함수로 결합한 예시다.<br/>
`mergeObjects` 함수를 이용해 `INameable & IAgeable` 타입의 변수인 `nameAndAge` 객체에 저장한다.<br/>

### 합집합 타입 구분하기

아래와 같인 인터페이스가 세 개 있다고 가정한다.<br/>

```typescript
interface ISquare {
    size: number;
}
interface IRectangle {
    width: number;
    height: number;
}
interface ICircle {
    radius: number;
}
```

위 인터페이스로 만든 각각의 객체는 아래와 같다.<br/>

```typescript
const square: ISquare = { size: 10 };
const rectangle: IRectangle = { width: 4, height: 5 };
const circle: ICircle = { radius: 10 };
```

이 객체들을 모두 받아 면적을 계산해 주는 함수인 `calcArea` 함수를 생각해 볼 수 있다.<br/>

```typescript
console.log(calcArea(square));
console.log(calcArea(rectangle));
console.log(calcArea(circle));
```

함수가 위와 같이 동작하려면 매개변수 타입은 `ISquare`, `IRectangle`, `ICircle`의 합집합이어야 한다.<br/>

```typescript
type IShape = ISquare | IRectangle | ICircle;

export const calcArea = (shape: IShape): number => {
    // shape 객체의 구체적인 타입을 알 수 없음
    return 0;
};
```

하지만 매개변수로 받은 `shape`가 **어떤 타입의 객체인지 구분할 수 없어** 계산을 할 수 없다.<br/>
Typescript는 이러한 문제를 해결할 수 있도록 **식별 합집합**이라는 구문을 제공한다.<br/>

### 식별 합집합 구문

**식별 합집합 구문**을 사용하려면 **합집합**을 구성하는 인터페이스들이 같은 속성을 가지고 있어야 한다.<br/>
아래 코드에서 `ISquare`, `IRectangle`, `ICircle`은 모두 `tag`라는 이름의 공통 속성이 있다.<br/>

-   `IShape.ts`

```typescript
export interface ISquare {
    tag: "square";
    size: number;
}

export interface IRectangle {
    tag: "rectangle";
    width: number;
    height: number;
}
export interface ICircle {
    tag: "circle";
    radius: number;
}

export type IShape = ISquare | IRectangle | ICircle;
```

위와 같이 공통 속성이 있을 때 `area` 함수의 `switch` 구문과 같이 **식별 합집합**을 사용할 수 있다.<br/>

-   `calcArea.ts`

```typescript
import { IShape } from "./IShape";

export const calcArea = (shape: IShape): number => {
    switch (shape.tag) {
        case "square":
            return shape.size * shape.size;
        case "rectangle":
            return shape.width * shape.height;
        case "circle":
            return Math.PI * shape.radius * shape.radius;
    }
    return 0;
};
```

만약 `tag`와 같이 공통 속성이 없다면 `IShape`의 타입을 구분할 방법이 없다.<br/>
아래 코드로 **식별 합집합 구문**을 사용한 `calcArea` 함수를 테스트 할 수 있다<br/>

-   `calcArea-Test.ts`

```typescript
import { calcArea } from "./calcArea";
import { IRectangle, ISquare, ICircle } from "./IShape";

const square: ISquare = { tag: "square", size: 10 };
const rectangle: IRectangle = { tag: "rectangle", width: 4, height: 5 };
const circle: ICircle = { tag: "circle", radius: 10 };

console.log(calcArea(square)); // 100
console.log(calcArea(rectangle)); // 20
console.log(calcArea(circle)); // 314.1592653589793
```

위와 같이 **합집합 타입**인 `IShape`의 상세 타입을 식별해 값이 계산되는 것을 볼 수 있다.<br/>

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-4 타입 가드

### 클래스와 합집합 타입

아래와 같이 두 개의 클래스가 있다고 가정한다.<br/>

-   `BirdAndFish.ts`

```typescript
export class Bird {
    fly() {
        console.log("I'm flying.");
    }
}

export class Fish {
    swim() {
        console.log("I'm swimming");
    }
}
```

아래와 같이 `flyOrSwim`과 같은 함수를 구현할 때 매개변수 `o`는 `Bird`이거나 `Fish`다.<br/>

```typescript
import { Bird, Fish } from "./BirdAndFish";

export const flyOrSwim = (o: Bird | Fish): void => {
    // o.fly() or o.swim() ??
};
```

따라서 이후 실행해야할 함수가 `o.fly()`인지 `o.swim()`인지 알 수 없다.<br/>
즉 합집합 타입 `(Bird | Fish)`의 객체가 구체적으로 무엇인지 알아야 한다.<br/>

### instanceof 연산자

Javascript는 두 개의 피연산자가 필요한 `instanceof` 라는 이름의 연산자를 제공한다.<br/>

```javascript
객체 instanceof 타입;
```

`instanceof` 연산자를 사용하면 앞 `flyOrSwim` 함수는 다음과 같이 구현할 수 있다.<br/>

```typescript
import { Bird, Fish } from "./BirdAndFish";

export const flyOrSwim = (o: Bird | Fish): void => {
    if (o instanceof Bird) {
        (o as Bird).fly();
    } else if (o instanceof Fish) {
        (<Fish>o).swim();
    }
};
```

`o as Bird`나 `<Fish>o`와 같이 매개변수 `o`에 **타입 단언**을 사용할 수 있다.<br/>

### 타입 가드

Typescript에서 `instanceof` 연산자는 Javascript와 다르게 **타입 가드** 기능이 있다.<br/>
**타입 가드**는 타입을 변환하지 않은 코드 때문에 프로그램이 **비정상 종료되는 상황을 보호**한다.<br/>
아래 `flyOrSwim` 함수는 `instanceof` 연산자의 **타입 가드**를 사용해 `o`의 타입을 전환하지 않고 사용한다.<br/>

```typescript
import { Bird, Fish } from "./BirdAndFish";

export const flyOrSwim = (o: Bird | Fish): void => {
    if (o instanceof Bird) {
        o.fly();
    } else if (o instanceof Fish) {
        o.swim();
    }
};
```

Typescript는 `o instanceof Bird`가 `true`이면 변수 `o`를 자동으로 `Bird` 타입 객체로 전환한다.<br/>
마찬가지로 `o instanceof Fish`가 `true`이면 자동으로 `Fish` 타입 객체로 전환한다.<br/>

```typescript
import { flyOrSwim } from "./flyOrSwim";
import { Bird, Fish } from "./BirdAndFish";

[new Bird(), new Fish()].forEach(flyOrSwim);
// I'm flying.
// I'm swimming
```

위와 같이 코드를 작성해 실행해보면 **타입 단언**을 사용하지 않아도 정상 작동하는 것을 볼 수 있다.<br/>

### is 연산자를 활용한 사용자 정의 타입 가드 함수 제작

**타입 가드** 기능을 하는 `instanceof` 처럼 동작하는 함수 또한 구현할 수 있다.<br/>
**타입 가드** 기능을 하는 함수는 함수의 반환 타입 부분에 `is`라는 연산자를 사용해야 한다.<br/>
`is` 연산자를 사용하는 구문은 아래와 같이 작성한다.<br/>

```typescript
변수 is 타입
```

아래의 `isFlyable` 함수는 반환 타입이 `o is Bird` 이므로 **사용자 정의 타입 가드 함수**다.<br/>

-   `isFlyable.ts`

```typescript
import { Bird, Fish } from "./BirdAndFish";

export const isFlyable = (o: Bird | Fish): o is Bird => {
    return o instanceof Bird;
};
```

또한 아래의 `isSwimmalbe` 함수 또한 **사용자 정의 타입 가드 함수**다.<br/>

-   `isSwimmable.ts`

```typescript
import { Bird, Fish } from "./BirdAndFish";

export const isSwimmable = (o: Bird | Fish): o is Fish => {
    return o instanceof Fish;
};
```

**사용자 타입 가드 함수**는 `if`문에서 사용해야 한다.<br/>
아래 `swimOrFly` 함수는 두 개의 `if` 문에서 작성한 **사용자 정의 타입 가드 함수**를 사용한다.<br/>

-   `swimOrFly.ts`

```typescript
import { Bird, Fish } from "./BirdAndFish";
import { isSwimmable } from "./isSwimmable";
import { isFlyable } from "./isFlyable";

export const swimOrFly = (o: Bird | Fish): void => {
    if (isSwimmable(o)) {
        o.swim();
    } else if (isFlyable(o)) {
        o.fly();
    }
};
```

아래와 같이 `swimOrFly` 함수를 테스트하는 코드를 작성해 확인할 수 있다.<br/>

-   `swimOrFly-Test.ts`

```typescript
import { swimOrFly } from "./swimOrFly";
import { Bird, Fish } from "./BirdAndFish";

[new Bird(), new Fish()].forEach(swimOrFly);
// I'm flying.
// I'm swimming
```

`instanceof`를 사용한 **타입 가드**와 동일하게 작동하는 것을 볼 수 있다.<br/>

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-5 F-바운드 다형성

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-6 nullable 타입과 프로그램 안정성

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
